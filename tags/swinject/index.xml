<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swinject on Swift Injection</title>
    <link>https://yoichitgy.github.io/tags/swinject/</link>
    <description>Recent content in Swinject on Swift Injection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 10 Sep 2015 11:02:53 +0900</lastBuildDate>
    <atom:link href="https://yoichitgy.github.io/tags/swinject/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dependency Injection in MVVM Architecture with ReactiveCocoa Part 5: Asynchronous Image Load</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-5-asynchronous-image-load/</link>
      <pubDate>Thu, 10 Sep 2015 11:02:53 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-5-asynchronous-image-load/</guid>
      <description>

&lt;p&gt;By &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-4-implementing-the-view-and-viewmodel/&#34;&gt;the previous blog post&lt;/a&gt;, we developed an example app, in MVVM architecture, displaying meta data of images received from &lt;a href=&#34;https://pixabay.com/&#34;&gt;Pixabay&lt;/a&gt; server. In this blog post, we are going add a feature to asynchronously load the images. To handle the asynchronous events, &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt; will be used as we did in the previous posts. Through the development, we will learn how to add a feature in MVVM architecture with unit tests and dependency injection are updated.&lt;/p&gt;

&lt;p&gt;The source code used in the blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;notice:e195b0dcdb12716d5c3e3911b931c7d6&#34;&gt;Notice&lt;/h2&gt;

&lt;p&gt;To use with Swift 2.0, a development version of ReactiveCocoa in &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/tree/swift2&#34;&gt;swift2 branch&lt;/a&gt; is used. Notice that ReactiveCocoa 3.0 has functional style APIs like &lt;code&gt;|&amp;gt; map&lt;/code&gt; or &lt;code&gt;|&amp;gt; flatMap&lt;/code&gt;, but APIs in swift2 branch are in protocol oriented and fluent style like &lt;code&gt;.map()&lt;/code&gt; or &lt;code&gt;.flatMap()&lt;/code&gt;. Since swift2 branch is still in development, the APIs might be changed in the future.&lt;/p&gt;

&lt;h2 id=&#34;model:e195b0dcdb12716d5c3e3911b931c7d6&#34;&gt;Model&lt;/h2&gt;

&lt;p&gt;First, we are going to add the feature to request an image to our Model. Add &lt;code&gt;requestImage&lt;/code&gt; method to &lt;code&gt;Networking&lt;/code&gt; protocol. The method takes an image URL and returns a SignalProducer instance to send the image.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Networking.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa

public protocol Networking {
    // Omitted

    func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify &lt;code&gt;Network&lt;/code&gt; class to implement &lt;code&gt;requestImage&lt;/code&gt; method. In the method, the initializer of &lt;code&gt;SignalProducer&lt;/code&gt; with a trailing closure is used to convert an asynchronous response of Alamofire to a &lt;code&gt;Signal&lt;/code&gt; of ReactiveCocoa. If the response is successful and its data are valid, &lt;code&gt;.Next&lt;/code&gt; and &lt;code&gt;.Completed&lt;/code&gt; events are sent to &lt;code&gt;observer&lt;/code&gt;. Otherwise an &lt;code&gt;.Error&lt;/code&gt; event is sent. Because the response of Alamofire runs in the main thread by default, a serial queue is passed to Alamofire.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Network.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa
import Alamofire

public final class Network: Networking {
    private let queue = dispatch_queue_create(
        &amp;quot;SwinjectMMVMExample.ExampleModel.Network.Queue&amp;quot;,
        DISPATCH_QUEUE_SERIAL)

    // Omitted

    public func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
        return SignalProducer { observer, disposable in
            let serializer = Alamofire.Request.dataResponseSerializer()
            Alamofire.request(.GET, url)
                .response(queue: self.queue, responseSerializer: serializer) {
                    _, _, result in
                    switch result {
                    case .Success(let data):
                        guard let image = UIImage(data: data) else {
                            sendError(observer, .IncorrectDataReturned)
                            return
                        }
                        sendNext(observer, image)
                        sendCompleted(observer)
                    case .Failure(_, let error):
                        sendError(observer, NetworkError(error: error))
                    }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Update stubs used in &lt;code&gt;ImageSearchSpec&lt;/code&gt; since &lt;code&gt;requestImage&lt;/code&gt; method was added to &lt;code&gt;Networking&lt;/code&gt; protocol. Because &lt;code&gt;requestImage&lt;/code&gt; method is not used in the unit tests, each stub method just returns an empty &lt;code&gt;SignalProducer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import ReactiveCocoa
@testable import ExampleModel

class ImageSearchSpec: QuickSpec {
    // MARK: Stub
    class GoodStubNetwork: Networking {
        // Omitted

        func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
            return SignalProducer.empty
        }
    }

    class BadStubNetwork: Networking {
        // Omitted

        func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
            return SignalProducer.empty
        }
    }

    class ErrorStubNetwork: Networking {
        // Omitted

        func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
            return SignalProducer.empty
        }
    }

    // Omitted
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add unit tests to &lt;code&gt;NetworkSpec&lt;/code&gt; to check the new &lt;code&gt;requestImage&lt;/code&gt; method. As a stable server for the tests, &lt;a href=&#34;http://httpbin.org&#34;&gt;httpbin.org&lt;/a&gt; is used.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NetworkSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
@testable import ExampleModel

class NetworkSpec: QuickSpec {
    override func spec() {
        var network: Network!
        beforeEach {
            network = Network()
        }

        // Omitted

        describe(&amp;quot;Image&amp;quot;) {
            it(&amp;quot;eventually gets an image.&amp;quot;) {
                var image: UIImage?
                network.requestImage(&amp;quot;https://httpbin.org/image/jpeg&amp;quot;)
                    .on(next: { image = $0 })
                    .start()

                expect(image).toEventuallyNot(beNil(), timeout: 5)
            }
            it(&amp;quot;eventually gets an error if incorrect data for an image is returned.&amp;quot;) {
                var error: NetworkError?
                network.requestImage(&amp;quot;https://httpbin.org/get&amp;quot;)
                    .on(error: { error = $0 })
                    .start()

                expect(error).toEventually(
                    equal(NetworkError.IncorrectDataReturned), timeout: 5)
            }
            it(&amp;quot;eventually gets an error if the network has a problem.&amp;quot;) {
                var error: NetworkError? = nil
                network.requestImage(&amp;quot;https://not.existing.server.comm/image/jpeg&amp;quot;)
                    .on(error: { error = $0 })
                    .start()

                expect(error).toEventually(
                    equal(NetworkError.NotReachedServer), timeout: 5)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first test checks that &lt;code&gt;Network&lt;/code&gt; returns an image asynchronously as a successful case. The second test checks that &lt;code&gt;Network&lt;/code&gt; sends &lt;code&gt;NetworkError.IncorrectDataReturned&lt;/code&gt; error if non-image data are returned from the server. The third test checks that an error from Alamofire is converted to its corresponding &lt;code&gt;NetworkError&lt;/code&gt; and passed through the &lt;code&gt;Network&lt;/code&gt; instance.&lt;/p&gt;

&lt;p&gt;Type &lt;code&gt;Command-U&lt;/code&gt; to run the unit tests.&lt;/p&gt;

&lt;h2 id=&#34;viewmodel:e195b0dcdb12716d5c3e3911b931c7d6&#34;&gt;ViewModel&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s move on to our ViewModel to receive the image from Model and to handle it for View. At the beginning, add &lt;code&gt;RACUtil.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleViewModel&lt;/code&gt; group. Make sure that it is added to &lt;code&gt;ExampleViewModel&lt;/code&gt; target when you save them.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RACUtil.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import ReactiveCocoa

internal extension NSObject {
    internal var racutil_willDeallocProducer: SignalProducer&amp;lt;(), NoError&amp;gt;  {
        return self.rac_willDeallocSignal()
            .toSignalProducer()
            .map { _ in }
            .flatMapError { _ in SignalProducer(value: ()) }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the extension to &lt;code&gt;NSObject&lt;/code&gt;, &lt;code&gt;rac_willDeallocSignal&lt;/code&gt; is mapped to a &lt;code&gt;SignalProducer&lt;/code&gt; that sends an event with an empty tuple when an object is being deallocated. We add the extension here because ReactiveCocoa Swift APIs still do not have an extension equivalent to &lt;code&gt;rac_willDeallocSignal&lt;/code&gt; supported by Objective-C APIs. &lt;code&gt;toSignalProducer&lt;/code&gt; is used to convert the Objective-C &lt;code&gt;Signal&lt;/code&gt; to Swift &lt;code&gt;SignalProducer&lt;/code&gt;, and &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMapError&lt;/code&gt; are used to transform the event and error types.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;getPreviewImage&lt;/code&gt; method to &lt;code&gt;ImageSearchTableViewCellModeling&lt;/code&gt; protocol and &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; class as followings.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModeling.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa

public protocol ImageSearchTableViewCellModeling {
    var id: UInt64 { get }
    var pageImageSizeText: String { get }
    var tagText: String { get }

    func getPreviewImage() -&amp;gt; SignalProducer&amp;lt;UIImage?, NoError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModel.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa
import ExampleModel

public final class ImageSearchTableViewCellModel
    : NSObject, ImageSearchTableViewCellModeling
{
    public let id: UInt64
    public let pageImageSizeText: String
    public let tagText: String

    private let network: Networking
    private let previewURL: String
    private var previewImage: UIImage?

    internal init(image: ImageEntity, network: Networking) {
        id = image.id
        pageImageSizeText = &amp;quot;\(image.pageImageWidth) x \(image.pageImageHeight)&amp;quot;
        tagText = image.tags.joinWithSeparator(&amp;quot;, &amp;quot;)

        self.network = network
        previewURL = image.previewURL

        super.init()
    }

    public func getPreviewImage() -&amp;gt; SignalProducer&amp;lt;UIImage?, NoError&amp;gt; {
        if let previewImage = self.previewImage {
            return SignalProducer(value: previewImage).observeOn(UIScheduler())
        }
        else {
            let imageProducer = network.requestImage(previewURL)
                .takeUntil(self.racutil_willDeallocProducer)
                .on(next: { self.previewImage = $0 })
                .map { $0 as UIImage? }
                .flatMapError { _ in SignalProducer&amp;lt;UIImage?, NoError&amp;gt;(value: nil) }

            return SignalProducer(value: nil)
                .concat(imageProducer)
                .observeOn(UIScheduler())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getPreviewImage&lt;/code&gt; method returns a &lt;code&gt;SignalProducer&lt;/code&gt; instance sending &lt;code&gt;UIImage&lt;/code&gt;. A cached image, as &lt;code&gt;previewImage&lt;/code&gt; property, is wrapped in an &lt;code&gt;SignalProducer&lt;/code&gt; instance if the cache exists. Otherwise, another &lt;code&gt;SignalProducer&lt;/code&gt; that requests an image to &lt;code&gt;Networking&lt;/code&gt; is returned.&lt;/p&gt;

&lt;p&gt;The latter &lt;code&gt;SignalProducer&lt;/code&gt; consists of two parts concatenated by &lt;code&gt;concat&lt;/code&gt; method. The first part is &lt;code&gt;SignalProducer(value: nil)&lt;/code&gt;, which sends &lt;code&gt;nil&lt;/code&gt; then completes immediately. The second part is &lt;code&gt;imageProducer&lt;/code&gt;, which requests the image to &lt;code&gt;Networking&lt;/code&gt;. In the second part, an error is mapped to &lt;code&gt;nil&lt;/code&gt; by &lt;code&gt;flatMapError&lt;/code&gt; to ignore the error because no error message should be displayed for each cell. To terminate the signal producer when the &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; instance is deallocated, &lt;code&gt;takeUntil&lt;/code&gt; method is called with &lt;code&gt;racutil_willDeallocProducer&lt;/code&gt;. To use the &lt;code&gt;NSObject&lt;/code&gt; extension, &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; inherits &lt;code&gt;NSObject&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Modify &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt; to pass a &lt;code&gt;Networking&lt;/code&gt; instance as below. A parameter is added to its initializer to get &lt;code&gt;Networking&lt;/code&gt; instance injected. The instance is passed to the initializer of &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; in &lt;code&gt;startSearch&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModel.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa
import ExampleModel

public final class ImageSearchTableViewModel: ImageSearchTableViewModeling {
    public var cellModels: PropertyOf&amp;lt;[ImageSearchTableViewCellModeling]&amp;gt; {
        return PropertyOf(_cellModels)
    }
    private let _cellModels = MutableProperty&amp;lt;[ImageSearchTableViewCellModeling]&amp;gt;([])
    private let imageSearch: ImageSearching
    private let network: Networking

    public init(imageSearch: ImageSearching, network: Networking) {
        self.imageSearch = imageSearch
        self.network = network
    }

    public func startSearch() {
        imageSearch.searchImages()
            .map { response in
                response.images.map {
                    ImageSearchTableViewCellModel(image: $0, network: self.network)
                        as ImageSearchTableViewCellModeling
                }
            }
            .observeOn(UIScheduler())
            .on(next: { cellModels in
                self._cellModels.value = cellModels
            })
            .start()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At last, modify &lt;code&gt;AppDelegate&lt;/code&gt; to add dependency injection of &lt;code&gt;Networking&lt;/code&gt; to &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt; as shown below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    var container: Container {
        let container = Container()

        // Models
        container.register(Networking.self) { _ in Network() }
        container.register(ImageSearching.self) { r in
            ImageSearch(network: r.resolve(Networking.self)!)
        }

        // View models
        container.register(ImageSearchTableViewModeling.self) { r in
            ImageSearchTableViewModel(
                imageSearch: r.resolve(ImageSearching.self)!,
                network: r.resolve(Networking.self)!)
        }

        // Views
        container.registerForStoryboard(ImageSearchTableViewController.self) { r, c in
            c.viewModel = r.resolve(ImageSearchTableViewModeling.self)!
        }

        return container
    }

    // Omitted
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s modify and add unit tests for the updated ViewModel. First, modify &lt;code&gt;ImageSearchTableViewModelSpec&lt;/code&gt; to add &lt;code&gt;StubNetwork&lt;/code&gt; and pass its instance to the modified initializer of &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModelSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ImageSearchTableViewModelSpec: QuickSpec {
    // MARK: Stub
    class StubImageSearch: ImageSearching {
        func searchImages() -&amp;gt; SignalProducer&amp;lt;ResponseEntity, NetworkError&amp;gt; {
            return SignalProducer { observer, disposable in
                sendNext(observer, dummyResponse)
                sendCompleted(observer)
            }
            .observeOn(QueueScheduler())
        }
    }

    class StubNetwork: Networking {
        func requestJSON(url: String, parameters: [String : AnyObject]?)
            -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
        {
            return SignalProducer.empty
        }

        func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
            return SignalProducer.empty
        }
    }

    // MARK: Spec
    override func spec() {
        var viewModel: ImageSearchTableViewModel!
        beforeEach {
            viewModel = ImageSearchTableViewModel(
                imageSearch: StubImageSearch(),
                network: StubNetwork())
        }

        // Omitted
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add a dummy image instance to &lt;code&gt;DummyResponse.swift&lt;/code&gt;. The instance will be used later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DummyResponse.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let image1x1: UIImage = {
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(1, 1), true, 0)
    let image = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()
    return image
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add stubs and unit tests to &lt;code&gt;ImageSearchTableViewCellModelSpec&lt;/code&gt; as below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModelSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import Quick
import Nimble
import ReactiveCocoa
@testable import ExampleModel
@testable import ExampleViewModel

class ImageSearchTableViewCellModelSpec: QuickSpec {
    // MARK: Stubs
    class StubNetwork: Networking {
        func requestJSON(url: String, parameters: [String : AnyObject]?)
            -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
        {
            return SignalProducer.empty
        }

        func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
            return SignalProducer(value: image1x1).observeOn(QueueScheduler())
        }
    }

    class ErrorStubNetwork: Networking {
        func requestJSON(url: String, parameters: [String : AnyObject]?)
            -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
        {
            return SignalProducer.empty
        }

        func requestImage(url: String) -&amp;gt; SignalProducer&amp;lt;UIImage, NetworkError&amp;gt; {
            return SignalProducer(error: .NotConnectedToInternet)
        }
    }

    // MARK: Spec
    override func spec() {
        var viewModel: ImageSearchTableViewCellModel!
        beforeEach {
            viewModel = ImageSearchTableViewCellModel(
                image: dummyResponse.images[0],
                network: StubNetwork())
        }

        describe(&amp;quot;Constant values&amp;quot;) {
            it(&amp;quot;sets id.&amp;quot;) {
                expect(viewModel.id).toEventually(equal(10000))
            }
            it(&amp;quot;formats tag and page image size texts.&amp;quot;) {
                expect(viewModel.pageImageSizeText)
                    .toEventually(equal(&amp;quot;1000 x 2000&amp;quot;))
                expect(viewModel.tagText).toEventually(equal(&amp;quot;a, b&amp;quot;))
            }
        }
        describe(&amp;quot;Preview image&amp;quot;) {
            it(&amp;quot;returns nil at the first time.&amp;quot;) {
                var image: UIImage? = image1x1
                viewModel.getPreviewImage()
                    .take(1)
                    .on(next: { image = $0 })
                    .start()

                expect(image).toEventually(beNil())
            }
            it(&amp;quot;eventually returns an image.&amp;quot;) {
                var image: UIImage? = nil
                viewModel.getPreviewImage()
                    .on(next: { image = $0 })
                    .start()

                expect(image).toEventuallyNot(beNil())
            }
            it(&amp;quot;returns an image on the main thread.&amp;quot;) {
                var onMainThread = false
                viewModel.getPreviewImage()
                    .skip(1) // Skips the first nil.
                    .on(next: { _ in onMainThread = NSThread.isMainThread() })
                    .start()

                expect(onMainThread).toEventually(beTrue())
            }
            context(&amp;quot;with an image already downloaded&amp;quot;) {
                it(&amp;quot;immediately returns the image omitting the first nil.&amp;quot;) {
                    var image: UIImage? = nil
                    viewModel.getPreviewImage().start(completed: {
                        viewModel.getPreviewImage()
                            .take(1)
                            .on(next: { image = $0 })
                            .start()
                    })

                    expect(image).toEventuallyNot(beNil())
                }
            }
            context(&amp;quot;on error&amp;quot;) {
                it(&amp;quot;returns nil.&amp;quot;) {
                    var image: UIImage? = image1x1
                    let viewModel = ImageSearchTableViewCellModel(
                        image: dummyResponse.images[0],
                        network: ErrorStubNetwork())
                    viewModel.getPreviewImage()
                        .skip(1) // Skips the first nil.
                        .on(next: { image = $0 })
                        .start()

                    expect(image).toEventually(beNil())
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;requestImage&lt;/code&gt; method of &lt;code&gt;StubNetwork&lt;/code&gt; returns a &lt;code&gt;SignalProducer&lt;/code&gt; sending the dummy image. That of &lt;code&gt;ErrorStubNetwork&lt;/code&gt; returns a &lt;code&gt;SignalProducer&lt;/code&gt; sending an error. Before adding new unit tests, refactoring is done on &lt;code&gt;spec&lt;/code&gt;. The existing tests are grouped within &lt;code&gt;describe(&amp;quot;Constant values&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Five new unit tests for &lt;code&gt;getPreviewImage&lt;/code&gt; method are added to &lt;code&gt;describe(&amp;quot;Preview image&amp;quot;)&lt;/code&gt; group. The first test checks the &lt;code&gt;SignalProducer&lt;/code&gt; sends &lt;code&gt;nil&lt;/code&gt; as its first event. The second test checks it sends an image as the succeeding event. The third test checks the image event is sent on the main thread. The forth test checks a cached image is sent immediately in case the cache exists. The test is grouped within &lt;code&gt;context&lt;/code&gt; because the test is in the certain condition. The fifth test checks that an error on &lt;code&gt;Networking&lt;/code&gt; instance is converted and sent as &lt;code&gt;nil&lt;/code&gt;. This test is also grouped within &lt;code&gt;context&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Input &lt;code&gt;Command-U&lt;/code&gt; and run the unit tests. Move on to the next section to implement our View.&lt;/p&gt;

&lt;h2 id=&#34;view:e195b0dcdb12716d5c3e3911b931c7d6&#34;&gt;View&lt;/h2&gt;

&lt;p&gt;First, we are going to add an extension to &lt;code&gt;UITableViewCell&lt;/code&gt; in the same way as we did to &lt;code&gt;NSObject&lt;/code&gt;. Add &lt;code&gt;RACUtil.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleView&lt;/code&gt; group. Make sure that it is added to &lt;code&gt;ExampleView&lt;/code&gt; target. In the extension, &lt;code&gt;rac_prepareForReuseSignal&lt;/code&gt;, as ReactiveCocoa Objective-C API, is transformed to a corresponding Swift instance. It sends an event with an empty tuple when &lt;code&gt;prepareForReuse&lt;/code&gt; of &lt;code&gt;UITableViewCell&lt;/code&gt; is invoked.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RACUtil.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import ReactiveCocoa

internal extension UITableViewCell {
    internal var racutil_prepareForReuseProducer: SignalProducer&amp;lt;(), NoError&amp;gt;  {
        return self.rac_prepareForReuseSignal
            .toSignalProducer()
            .map { _ in }
            .flatMapError { _ in SignalProducer(value: ()) }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, modify &lt;code&gt;ImageSearchTableViewCell&lt;/code&gt; to update the image view when &lt;code&gt;viewModel&lt;/code&gt; property is set. The signal of &lt;code&gt;getPreviewImage&lt;/code&gt; is terminated upon reuse of the cell for another table row to avoid updating the cell with the image used for the previous row.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCell.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import ExampleViewModel
import ReactiveCocoa

internal final class ImageSearchTableViewCell: UITableViewCell {
    internal var viewModel: ImageSearchTableViewCellModeling? {
        didSet {
            tagLabel.text = viewModel?.tagText
            imageSizeLabel.text = viewModel?.pageImageSizeText

            if let viewModel = viewModel {
                viewModel.getPreviewImage()
                    .takeUntil(self.racutil_prepareForReuseProducer)
                    .on(next: { self.previewImageView.image = $0 })
                    .start()
            }
            else {
                previewImageView.image = nil
            }
        }
    }

    @IBOutlet weak var previewImageView: UIImageView!
    @IBOutlet weak var tagLabel: UILabel!
    @IBOutlet weak var imageSizeLabel: UILabel!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type &lt;code&gt;Command-R&lt;/code&gt; and run the app. You will see each image view is filled like the following image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleCellsWithImagesScreenshot.png&#34; alt=&#34;SwinjectMVVMExample Images Displayed in Table View Cells&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At last, add &lt;code&gt;ImageSearchTableViewCellSpec.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleViewTests&lt;/code&gt; group. Make sure that it is added to &lt;code&gt;ExampleViewTests&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import ReactiveCocoa
import ExampleViewModel
@testable import ExampleView

class ImageSearchTableViewCellSpec: QuickSpec {
    class MockViewModel: ImageSearchTableViewCellModeling {
        let id: UInt64 = 0
        let pageImageSizeText = &amp;quot;&amp;quot;
        let tagText = &amp;quot;&amp;quot;

        var getPreviewImageStarted = false

        func getPreviewImage() -&amp;gt; SignalProducer&amp;lt;UIImage?, NoError&amp;gt; {
            return SignalProducer&amp;lt;UIImage?, NoError&amp;gt; { observer, _ in
                self.getPreviewImageStarted = true
                sendCompleted(observer)
            }
        }
    }

    override func spec() {
        it(&amp;quot;starts getPreviewImage signal producer when its view model is set.&amp;quot;) {
            let viewModel = MockViewModel()
            let view = createTableViewCell()

            expect(viewModel.getPreviewImageStarted) == false
            view.viewModel = viewModel
            expect(viewModel.getPreviewImageStarted) == true
        }
    }
}

private func createTableViewCell() -&amp;gt; ImageSearchTableViewCell {
    let bundle = NSBundle(forClass: ImageSearchTableViewCell.self)
    let storyboard = UIStoryboard(name: &amp;quot;Main&amp;quot;, bundle: bundle)
    let tableViewController = storyboard
        .instantiateViewControllerWithIdentifier(&amp;quot;ImageSearchTableViewController&amp;quot;)
        as! ImageSearchTableViewController
    return tableViewController.tableView
        .dequeueReusableCellWithIdentifier(&amp;quot;ImageSearchTableViewCell&amp;quot;)
        as! ImageSearchTableViewCell
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The test checks, with a mock of &lt;code&gt;ImageSearchTableViewCellModeling&lt;/code&gt;, &lt;code&gt;getPreviewImage&lt;/code&gt; is called when &lt;code&gt;viewModel&lt;/code&gt; property of &lt;code&gt;ImageSearchTableViewCell&lt;/code&gt; is set.&lt;/p&gt;

&lt;p&gt;Input &lt;code&gt;Command-U&lt;/code&gt; to run the test. Passed! We have finished implementing the table view displaying images that are asynchronously loaded from the network. Remember now we have not only the implementation but also the unit tests that give us confidence to keep developing working software!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:e195b0dcdb12716d5c3e3911b931c7d6&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this blog post, we implemented the feature to asynchronously load an image to &lt;code&gt;UIImageView&lt;/code&gt; in MVVM architecture. We learned how to add new methods to protocols and their conforming classes with the update of unit tests in Model, ViewModel and View. The dependency injection to ViewModel was also updated during the implementation. ReactiveCocoa was used throughout the Model, ViewModel and View to pass and handle events in the abstracted way.&lt;/p&gt;

&lt;p&gt;Through the series of the blog posts, we learned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Part 1: The concepts and basics of MVVM and ReactiveCocoa.&lt;/li&gt;
&lt;li&gt;Part 2: The setup of Xcode project composed of MVVM framework targets with external frameworks installed via &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Part 3: The model design using protocols to decouple our app from external system, e.g. network.&lt;/li&gt;
&lt;li&gt;Part 4: ViewModel and View implementation with dependencies injected by AppDelegate.&lt;/li&gt;
&lt;li&gt;Part 5: Modification of Model, ViewModel and View to add a new feature with unit tests updated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We did not only develop the example app but wrote unit tests&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:e195b0dcdb12716d5c3e3911b931c7d6:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:e195b0dcdb12716d5c3e3911b931c7d6:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; that use stubs and mocks of protocols representing MVVM interfaces. Keeping the cycle to add protocols, implementations, and unit tests in MVVM architecture, we are always confident to develop the project further. Decoupling of Model, View and ViewModel by using the abstracted events of &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;ReactiveCocoa&lt;/a&gt; and dependency injection with &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt; is the key to the cycle.&lt;/p&gt;

&lt;p&gt;The series of the blog posts ends here, but &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;the project in the GitHub repository&lt;/a&gt; has further development to show image details, to receive more image data when scrolled to the bottom of the table, to handle errors and to add localization. If you are interested, check the project. Adding a star to &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject project&lt;/a&gt; is highly appreciated.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:e195b0dcdb12716d5c3e3911b931c7d6:1&#34;&gt;The blog posts always wrote unit tests after implementing features, but actually tests should be written first or together with the feature implementation.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:e195b0dcdb12716d5c3e3911b931c7d6:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection in MVVM Architecture with ReactiveCocoa Part 4: Implementing the View and ViewModel</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-4-implementing-the-view-and-viewmodel/</link>
      <pubDate>Wed, 02 Sep 2015 12:10:55 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-4-implementing-the-view-and-viewmodel/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-3-designing-the-model/&#34;&gt;the last blog post&lt;/a&gt;, we developed the Model part of the example app. In this blog post, we will move on to the View and ViewModel parts. First, empty implementation of View and ViewModel will be added to the project to get working software. Then actual implementation will be added with unit tests. During the development, we will learn how to use &lt;code&gt;PropertyOf&lt;/code&gt; and &lt;code&gt;MutableProperty&lt;/code&gt; types, which are observable properties provided by &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/&#34;&gt;ReactiveCocoa&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The source code used in the blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;notice:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Notice&lt;/h2&gt;

&lt;p&gt;In the example project, Swift 2.0 with Xcode 7 is used though they are still in beta versions. To use with Swift 2.0, a development version of ReactiveCocoa in &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/tree/swift2&#34;&gt;swift2 branch&lt;/a&gt; is used. Notice that ReactiveCocoa 3.0 has functional style APIs like &lt;code&gt;|&amp;gt; map&lt;/code&gt; or &lt;code&gt;|&amp;gt; flatMap&lt;/code&gt;, but APIs in swift2 branch are in protocol oriented and fluent style like &lt;code&gt;.map()&lt;/code&gt; or &lt;code&gt;.flatMap()&lt;/code&gt;. Since swift2 branch is still in development, the APIs might be changed in the future.&lt;/p&gt;

&lt;h2 id=&#34;view-and-viewmodel-design-overview:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;View and ViewModel Design Overview&lt;/h2&gt;

&lt;p&gt;To decouple View and ViewModel, the interfaces are defined as protocols as shown in the diagram below. &lt;code&gt;ImageSearchTableViewModeling&lt;/code&gt; and &lt;code&gt;ImageSearchTableViewCellModeling&lt;/code&gt; are protocols. &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt; and &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; are their implementation conforming the protocols. &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt; receives image entities wrapped in an event from the Model layer, and converts them to &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; instances to pass to &lt;code&gt;ImageSearchTableViewController&lt;/code&gt; in an event.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleViewAndViewModelDesign.png&#34; alt=&#34;View and View Model Design&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;empty-implementation-of-view-and-viewmodel:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Empty Implementation of View and ViewModel&lt;/h2&gt;

&lt;p&gt;At the beginning, we are going to add empty implementation of View and ViewModel with dependency injection by &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;. You can get still empty but working software first, then add features one by one as &lt;a href=&#34;https://en.wikipedia.org/wiki/Agile_software_development&#34;&gt;the Agile practices&lt;/a&gt; promote.&lt;/p&gt;

&lt;h3 id=&#34;adding-empty-view:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Adding Empty View&lt;/h3&gt;

&lt;p&gt;First, delete unnecessary files and a setting. Delete &lt;code&gt;ViewController.swift&lt;/code&gt; and &lt;code&gt;Main.storyboard&lt;/code&gt; in &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; group. Open &lt;code&gt;Info.plist&lt;/code&gt; in &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; group, and delete &lt;code&gt;Main storyboard file base name&lt;/code&gt; item (or &lt;code&gt;UIMainStoryboardFile&lt;/code&gt; item if you are displaying raw keys/values).&lt;/p&gt;

&lt;p&gt;Then add &lt;code&gt;ImageSearchTableViewController.swift&lt;/code&gt; with the following contents to &lt;code&gt;ExampleView&lt;/code&gt; group. Make sure that the file is added to &lt;code&gt;ExampleView&lt;/code&gt; target. To add it to the target, right click on &lt;code&gt;ExampleView&lt;/code&gt; group, select &lt;code&gt;New File...&lt;/code&gt;, navigate to &lt;code&gt;iOS &amp;gt; Source &amp;gt; Swift File&lt;/code&gt; item, and check &lt;code&gt;ExampleView&lt;/code&gt; target when you are asked to name the file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit

public final class ImageSearchTableViewController: UITableViewController {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same way, add &lt;code&gt;ImageSearchTableViewCell.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleView&lt;/code&gt; group.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCell.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit

internal final class ImageSearchTableViewCell: UITableViewCell {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;ImageSearchTableViewController&lt;/code&gt; is &lt;code&gt;public&lt;/code&gt; but &lt;code&gt;ImageSearchTableViewCell&lt;/code&gt; is &lt;code&gt;internal&lt;/code&gt; because the cell is handled by only the table view controller and it should not be visible to the user of &lt;code&gt;ExampleView&lt;/code&gt; framework.&lt;/p&gt;

&lt;p&gt;Add a new storyboard named &lt;code&gt;Main.storyboard&lt;/code&gt; to &lt;code&gt;ExampleView&lt;/code&gt; group. Open the storyboard, and add a navigation controller to the storyboard from Object Library. Select the navigation controller and check &amp;ldquo;Is Initial View Controller&amp;rdquo; in Attribute Inspector.&lt;/p&gt;

&lt;p&gt;Select the table view controller, which is the root view controller of the navigation controller, and set its custom class and storyboard ID to &lt;code&gt;ImageSearchTableViewController&lt;/code&gt;. Select the prototype cell on the table view controller, and set its custom class and cell identifier to &lt;code&gt;ImageSearchTableViewCell&lt;/code&gt;. Select the navigation item on the table view controller, and set its title to &amp;ldquo;Pixabay Images&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleEmptyViewProject.png&#34; alt=&#34;SwinjectMVVMExampleEmptyViewProject&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleEmptyViewStoryboard.png&#34; alt=&#34;SwinjectMVVMExampleEmptyViewStoryboard&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Modify &lt;code&gt;AppDelegate.swift&lt;/code&gt; in &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; group to instantiate the initial view controller from the storyboard by hand. Here, we use &lt;code&gt;SwinjectStoryboard&lt;/code&gt; instead of &lt;code&gt;UIStoryboard&lt;/code&gt; to add dependency injection later. The instantiation of &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is not performed with an initializer but &lt;code&gt;create&lt;/code&gt; function&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:8877ce3a4a69e6ded4cb59057183d3db:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:8877ce3a4a69e6ded4cb59057183d3db:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. The bundle passed to &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is not the main bundle but the bundle in &lt;code&gt;ExampleView&lt;/code&gt; target. &lt;code&gt;NSBundle.init(forClass:)&lt;/code&gt; is used to get the bundle.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import Swinject
import ExampleView

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(
        application: UIApplication
        didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
    {
        let window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window.backgroundColor = UIColor.whiteColor()
        window.makeKeyAndVisible()
        self.window = window

        let bundle = NSBundle(forClass: ImageSearchTableViewController.self)
        let storyboard = SwinjectStoryboard.create(name: &amp;quot;Main&amp;quot;, bundle: bundle)
        window.rootViewController = storyboard.instantiateInitialViewController()

        return true
    }

    // Omitted...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are ready to run the app. Type &lt;code&gt;Command-R&lt;/code&gt; to run. You will see an empty table view like the following image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleEmptyViewScreenshot.png&#34; alt=&#34;SwinjectMVVMExampleEmptyViewScreenshot&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;adding-empty-viewmodel:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Adding Empty ViewModel&lt;/h3&gt;

&lt;p&gt;Add &lt;code&gt;ImageSearchTableViewModeling.swift&lt;/code&gt; and &lt;code&gt;ImageSearchTableViewModel.swift&lt;/code&gt; with the following contents to &lt;code&gt;ExampleViewModel&lt;/code&gt; group. Make sure that they are added to &lt;code&gt;ExampleViewModel&lt;/code&gt; target when you save them. The dependency of &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt; on &lt;code&gt;ImageSearching&lt;/code&gt; is injected through its initializer as &lt;a href=&#34;https://github.com/Swinject/Swinject/blob/master/Documentation/InjectionPatterns.md&#34;&gt;initializer injection pattern&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModeling.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public protocol ImageSearchTableViewModeling {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModel.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ExampleModel

public final class ImageSearchTableViewModel: ImageSearchTableViewModeling {
    private let imageSearch: ImageSearching

    public init(imageSearch: ImageSearching) {
        self.imageSearch = imageSearch
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;ImageSearchTableViewCellModeling.swift&lt;/code&gt; and &lt;code&gt;ImageSearchTableViewCellModel.swift&lt;/code&gt; with the following contents to &lt;code&gt;ExampleViewModel&lt;/code&gt; group.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModeling.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public protocol ImageSearchTableViewCellModeling {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModel.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public final class ImageSearchTableViewCellModel: ImageSearchTableViewCellModeling {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add the dependencies on the view models to &lt;code&gt;ImageSearchTableViewController&lt;/code&gt; and &lt;code&gt;ImageSearchTableViewCell&lt;/code&gt; as below by &lt;a href=&#34;https://github.com/Swinject/Swinject/blob/master/Documentation/InjectionPatterns.md&#34;&gt;property injection pattern&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import ExampleViewModel

public final class ImageSearchTableViewController: UITableViewController {
    public var viewModel: ImageSearchTableViewModeling?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCell.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import ExampleViewModel

internal final class ImageSearchTableViewCell: UITableViewCell {
    internal var viewModel: ImageSearchTableViewCellModeling?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;applying-dependency-injection:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Applying Dependency Injection&lt;/h3&gt;

&lt;p&gt;To apply dependency injection in &lt;code&gt;AppDelegate&lt;/code&gt;, add &lt;code&gt;container&lt;/code&gt; property registering the dependencies as below. The &lt;code&gt;container&lt;/code&gt; is passed to the factory method of &lt;code&gt;SwinjectStoryboard&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import Swinject
import ExampleModel
import ExampleViewModel
import ExampleView

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?
    var container: Container {
        let container = Container()

        // Models
        container.register(Networking.self) { _ in Network() }
        container.register(ImageSearching.self) { r in
            ImageSearch(network: r.resolve(Networking.self)!)
        }

        // View models
        container.register(ImageSearchTableViewModeling.self) { r
            in ImageSearchTableViewModel(imageSearch: r.resolve(ImageSearching.self)!)
        }

        // Views
        container.registerForStoryboard(ImageSearchTableViewController.self) {
            r, c in
            c.viewModel = r.resolve(ImageSearchTableViewModeling.self)!
        }

        return container
    }

    func application(
        application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
    {
        let window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window.backgroundColor = UIColor.whiteColor()
        window.makeKeyAndVisible()
        self.window = window

        let bundle = NSBundle(forClass: ImageSearchTableViewController.self)
        let storyboard = SwinjectStoryboard.create(
            name: &amp;quot;Main&amp;quot;,
            bundle: bundle,
            container: container)
        window.rootViewController = storyboard.instantiateInitialViewController()

        return true
    }
    // Omitted...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To ensure all the types are registered to &lt;code&gt;container&lt;/code&gt;, we should add unit tests. Before adding the tests, delete  &lt;code&gt;SwinjectMVVMExampleTests.swift&lt;/code&gt;, which is unnecessary, in &lt;code&gt;SwinjectMVVMExampleTests&lt;/code&gt; group. Then add &lt;code&gt;AppDelegateSpec.swift&lt;/code&gt; with the following content to the group. The tests use &lt;code&gt;.notTo(beNil())&lt;/code&gt; to check the types can be resolved by &lt;code&gt;container&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegateSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Swinject
import ExampleModel
import ExampleViewModel
import ExampleView
@testable import SwinjectMVVMExample

class AppDelegateSpec: QuickSpec {
    override func spec() {
        var container: Container!
        beforeEach {
            container = AppDelegate().container
        }

        describe(&amp;quot;Container&amp;quot;) {
            it(&amp;quot;resolves every service type.&amp;quot;) {
                // Models
                expect(container.resolve(Networking.self)).notTo(beNil())
                expect(container.resolve(ImageSearching.self)).notTo(beNil())

                // ViewModels
                expect(container.resolve(ImageSearchTableViewModeling.self))
                    .notTo(beNil())
            }
            it(&amp;quot;injects view models to views.&amp;quot;) {
                let bundle = NSBundle(forClass: ImageSearchTableViewController.self)
                let storyboard = SwinjectStoryboard.create(
                    name: &amp;quot;Main&amp;quot;,
                    bundle: bundle,
                    container: container)
                let imageSearchTableViewController = storyboard
                    .instantiateViewControllerWithIdentifier(&amp;quot;ImageSearchTableViewController&amp;quot;)
                    as! ImageSearchTableViewController

                expect(imageSearchTableViewController.viewModel).notTo(beNil())
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Input &lt;code&gt;Command-U&lt;/code&gt; and run the unit tests. Passed, right? We got the empty implementation of View and ViewModel with the dependencies injected.&lt;/p&gt;

&lt;h2 id=&#34;actual-implementation-of-view-and-viewmodel:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Actual Implementation of View and ViewModel&lt;/h2&gt;

&lt;p&gt;In this section, we are going to add actual implementation of View and ViewModel to display image meta data (tags and pixel sizes) in the table view. Although we will add a &lt;code&gt;UIImageView&lt;/code&gt; to the table view cell, only the labels for the meta data are implemented in this blog post. The image view will be used in the next blog post.&lt;/p&gt;

&lt;h3 id=&#34;viewmodel-implementation:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;ViewModel Implementation&lt;/h3&gt;

&lt;p&gt;First, let&amp;rsquo;s implement the table data source. In MVVM architecture, the data source is implemented in ViewModel. Add &lt;code&gt;cellModels&lt;/code&gt; property and &lt;code&gt;startSearch&lt;/code&gt; method to &lt;code&gt;ImageSearchTableViewModeling&lt;/code&gt; protocol.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModeling.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa

public protocol ImageSearchTableViewModeling {
    var cellModels: PropertyOf&amp;lt;[ImageSearchTableViewCellModeling]&amp;gt; { get }
    func startSearch()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cellModels&lt;/code&gt; property is defined as &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoa/Swift/Property.swift&#34;&gt;&lt;code&gt;PropertyOf&lt;/code&gt; type&lt;/a&gt; to make it observable. The type provides &lt;code&gt;producer&lt;/code&gt; property as &lt;code&gt;SignalProducer&lt;/code&gt; type to add observers.&lt;/p&gt;

&lt;p&gt;Modify &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt; to implement the property and method.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModel.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;    import ReactiveCocoa
    import ExampleModel

    public final class ImageSearchTableViewModel: ImageSearchTableViewModeling {
        public var cellModels: PropertyOf&amp;lt;[ImageSearchTableViewCellModeling]&amp;gt; {
            return PropertyOf(_cellModels)
        }
        private let _cellModels = MutableProperty&amp;lt;[ImageSearchTableViewCellModeling]&amp;gt;([])
        private let imageSearch: ImageSearching

        public init(imageSearch: ImageSearching) {
            self.imageSearch = imageSearch
        }

        public func startSearch() {
            imageSearch.searchImages()
                .map { response in
                    response.images.map {
                        ImageSearchTableViewCellModel(image: $0)
                            as ImageSearchTableViewCellModeling
                    }
                }
                .observeOn(UIScheduler())
                .on(next: { cellModels in
                    self._cellModels.value = cellModels
                })
                .start()
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cellModels&lt;/code&gt; property wraps &lt;code&gt;_cellModels&lt;/code&gt; property as &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md#properties&#34;&gt;&lt;code&gt;MutableProperty&lt;/code&gt; type&lt;/a&gt;. Because the type is not only observable but also modifiable, &lt;code&gt;_cellModels&lt;/code&gt; is &lt;code&gt;private&lt;/code&gt; and is wrapped by &lt;code&gt;PropertyOf&lt;/code&gt; type to provide a read-only property.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;startSearch&lt;/code&gt; method starts the &lt;code&gt;SignalProducer&lt;/code&gt; returned by &lt;code&gt;imageSearch.searchImages&lt;/code&gt;. As a side effect on the &lt;code&gt;next&lt;/code&gt; event, it sets the value of &lt;code&gt;_cellModels&lt;/code&gt; to an array of &lt;code&gt;ImageSearchTableViewCellModeling&lt;/code&gt; instances that is mapped from &lt;code&gt;response&lt;/code&gt; from &lt;code&gt;imageSearch&lt;/code&gt;. Notice that the side effect is configured to run in the main thread by &lt;code&gt;.observeOn(UIScheduler())&lt;/code&gt;. ViewModel should ensure that events from ViewModel to View are performed in the main thread.&lt;/p&gt;

&lt;p&gt;ReactiveCocoa provides two types of schedulers to run on the main thread. One is &lt;code&gt;QueueScheduler.mainQueueScheduler&lt;/code&gt;, which delivers events always on the main thread asynchronously. The other is &lt;code&gt;UIScheduler&lt;/code&gt;, as we used, which delivers events on the main thread synchronously if they are already on the main thread, otherwise asynchronously.&lt;/p&gt;

&lt;p&gt;Next, add &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;pageImageSizeText&lt;/code&gt; and &lt;code&gt;tagText&lt;/code&gt; properties to &lt;code&gt;ImageSearchTableViewCellModeling&lt;/code&gt; protocol. &lt;code&gt;id&lt;/code&gt; is added just for debugging purpose.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModeling.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public protocol ImageSearchTableViewCellModeling {
    var id: UInt64 { get }
    var pageImageSizeText: String { get }
    var tagText: String { get }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; to implement the protocol. The properties are set when it is initialized by &lt;code&gt;ImageSearchTableViewModel&lt;/code&gt;. What &lt;code&gt;ImageSearchTableViewCellModel&lt;/code&gt; implements are view logics defining how Model data are displayed in View.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModel.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ExampleModel

public final class ImageSearchTableViewCellModel: ImageSearchTableViewCellModeling {
    public let id: UInt64
    public let pageImageSizeText: String
    public let tagText: String

    internal init(image: ImageEntity) {
        id = image.id
        pageImageSizeText = &amp;quot;\(image.pageImageWidth) x \(image.pageImageHeight)&amp;quot;
        tagText = image.tags.joinWithSeparator(&amp;quot;, &amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;unit-tests-for-viewmodel-implementation:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Unit Tests for ViewModel Implementation&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s add unit tests to check our ViewModel implementation. First, delete &lt;code&gt;ExampleViewModelTests.swift&lt;/code&gt;, which is unnecessary, in &lt;code&gt;ExampleViewModelTests&lt;/code&gt; group. Then add &lt;code&gt;DummyResponse.swift&lt;/code&gt; and &lt;code&gt;ImageSearchTableViewModelSpec.swift&lt;/code&gt; with the following contents to the group.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DummyResponse.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@testable import ExampleModel
@testable import ExampleViewModel

let dummyResponse: ResponseEntity = {
    let image0 = ImageEntity(
        id: 10000,
        pageURL: &amp;quot;https://somewhere.com/page0/&amp;quot;,
        pageImageWidth: 1000,
        pageImageHeight: 2000,
        previewURL: &amp;quot;https://somewhere.com/preview0.jpg&amp;quot;,
        previewWidth: 250,
        previewHeight: 500,
        imageURL: &amp;quot;https://somewhere.com/image0.jpg&amp;quot;,
        imageWidth: 100,
        imageHeight: 200,
        viewCount: 99,
        downloadCount: 98,
        likeCount: 97,
        tags: [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;],
        username: &amp;quot;User0&amp;quot;)
    let image1 = ImageEntity(
        id: 10001,
        pageURL: &amp;quot;https://somewhere.com/page1/&amp;quot;,
        pageImageWidth: 1500,
        pageImageHeight: 3000,
        previewURL: &amp;quot;https://somewhere.com/preview1.jpg&amp;quot;,
        previewWidth: 350,
        previewHeight: 700,
        imageURL: &amp;quot;https://somewhere.com/image1.jpg&amp;quot;,
        imageWidth: 150,
        imageHeight: 300,
        viewCount: 123456789,
        downloadCount: 12345678,
        likeCount: 1234567,
        tags: [&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;],
        username: &amp;quot;User1&amp;quot;)
    return ResponseEntity(totalCount: 123, images: [image0, image1])
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewModelSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import ReactiveCocoa
@testable import ExampleModel
@testable import ExampleViewModel

class ImageSearchTableViewModelSpec: QuickSpec {
    // MARK: Stub
    class StubImageSearch: ImageSearching {
        func searchImages() -&amp;gt; SignalProducer&amp;lt;ResponseEntity, NetworkError&amp;gt; {
            return SignalProducer { observer, disposable in
                sendNext(observer, dummyResponse)
                sendCompleted(observer)
            }
            .observeOn(QueueScheduler())
        }
    }

    // MARK: Spec
    override func spec() {
        var viewModel: ImageSearchTableViewModel!
        beforeEach {
            viewModel = ImageSearchTableViewModel(imageSearch: StubImageSearch())
        }

        it(&amp;quot;eventually sets cellModels property after the search.&amp;quot;) {
            var cellModels: [ImageSearchTableViewCellModeling]? = nil
            viewModel.cellModels.producer
                .on(next: { cellModels = $0 })
                .start()
            viewModel.startSearch()

            expect(cellModels).toEventuallyNot(beNil())
            expect(cellModels?.count).toEventually(equal(2))
            expect(cellModels?[0].id).toEventually(equal(10000))
            expect(cellModels?[1].id).toEventually(equal(10001))
        }
        it(&amp;quot;sets cellModels property on the main thread.&amp;quot;) {
            var onMainThread = false
            viewModel.cellModels.producer
                .on(next: { _ in onMainThread = NSThread.isMainThread() })
                .start()
            viewModel.startSearch()

            expect(onMainThread).toEventually(beTrue())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The stub sends &lt;code&gt;dummyResponse&lt;/code&gt; wrapped in an event. The first test checks &lt;code&gt;cellModels&lt;/code&gt; property is asynchronously set to an array that is converted from &lt;code&gt;dummyResponse&lt;/code&gt;. The second test ensures that the event is delivered on the main thread.&lt;/p&gt;

&lt;p&gt;Next, add &lt;code&gt;ImageSearchTableViewCellSpec.swift&lt;/code&gt; to &lt;code&gt;ExampleViewModelTests&lt;/code&gt; group. It simply checks the value assignment to &lt;code&gt;id&lt;/code&gt; property and conversions to &lt;code&gt;pageImageSizeText&lt;/code&gt; and &lt;code&gt;tagText&lt;/code&gt; properties.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCellModelSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
@testable import ExampleModel
@testable import ExampleViewModel

class ImageSearchTableViewCellModelSpec: QuickSpec {
    override func spec() {
        it(&amp;quot;sets id.&amp;quot;) {
            let viewModel = ImageSearchTableViewCellModel(image: dummyResponse.images[0])

            expect(viewModel.id).toEventually(equal(10000))
        }
        it(&amp;quot;formats tag and page image size texts.&amp;quot;) {
            let viewModel = ImageSearchTableViewCellModel(image: dummyResponse.images[0])

            expect(viewModel.pageImageSizeText).toEventually(equal(&amp;quot;1000 x 2000&amp;quot;))
            expect(viewModel.tagText).toEventually(equal(&amp;quot;a, b&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type &lt;code&gt;Command-U&lt;/code&gt; and run the unit tests. Passed! Let&amp;rsquo;s move on to the next section.&lt;/p&gt;

&lt;h3 id=&#34;view-implementation:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;View Implementation&lt;/h3&gt;

&lt;p&gt;In this section, we are going to implement our View. Open &lt;code&gt;Main.storyboard&lt;/code&gt; and add a &lt;code&gt;UIImageView&lt;/code&gt; and two &lt;code&gt;UILabel&lt;/code&gt;s to the prototype cell. Layout and style them as you prefer. If you want to change the cell height, set &lt;code&gt;rowHeight&lt;/code&gt; property of the &lt;code&gt;UITableView&lt;/code&gt; (not &lt;code&gt;UITableViewController&lt;/code&gt;) in the storyboard on Size Inspector pane.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleStoryboardCellLayout.png&#34; alt=&#34;SwinjectMVVMExampleStoryboardCellLayout&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Then add outlets to &lt;code&gt;ImageSearchTableViewCell&lt;/code&gt; and connect them with the items in the storyboard.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewCell.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import ExampleViewModel

internal final class ImageSearchTableViewCell: UITableViewCell {
    internal var viewModel: ImageSearchTableViewCellModeling? {
        didSet {
            tagLabel.text = viewModel?.tagText
            imageSizeLabel.text = viewModel?.pageImageSizeText
        }
    }

    @IBOutlet weak var previewImageView: UIImageView!
    @IBOutlet weak var tagLabel: UILabel!
    @IBOutlet weak var imageSizeLabel: UILabel!
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice &lt;code&gt;didSet&lt;/code&gt; observer is added to &lt;code&gt;viewModel&lt;/code&gt; property to set label texts when the view model is assigned. An image will be added to the image view in the next blog post.&lt;/p&gt;

&lt;p&gt;Add implementation to &lt;code&gt;ImageSearchTableViewController&lt;/code&gt; as below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import ExampleViewModel

public final class ImageSearchTableViewController: UITableViewController {
    private var autoSearchStarted = false

    public var viewModel: ImageSearchTableViewModeling? {
        didSet {
            if let viewModel = viewModel {
                viewModel.cellModels.producer
                    .on(next: { _ in self.tableView.reloadData() })
                    .start()
            }
        }
    }

    public override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)

        if !autoSearchStarted {
            autoSearchStarted = true
            viewModel?.startSearch()
        }
    }
}

// MARK: UITableViewDataSource
extension ImageSearchTableViewController {
    public override func tableView(
        tableView: UITableView,
        numberOfRowsInSection section: Int) -&amp;gt; Int
    {
        if let viewModel = viewModel {
            return viewModel.cellModels.value.count
        }
        return 0
    }

    public override func tableView(
        tableView: UITableView,
        cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell
    {
        let cell = tableView.dequeueReusableCellWithIdentifier(
            &amp;quot;ImageSearchTableViewCell&amp;quot;,
            forIndexPath: indexPath) as! ImageSearchTableViewCell
        if let viewModel = viewModel {
            cell.viewModel = viewModel.cellModels.value[indexPath.row]
        }
        else {
            cell.viewModel = nil
        }

        return cell
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, &lt;code&gt;didSet&lt;/code&gt; observer is added to &lt;code&gt;viewModel&lt;/code&gt; property to add an observer to &lt;code&gt;viewModel.cellModels&lt;/code&gt; property. When &lt;code&gt;viewModel.cellModels&lt;/code&gt; is updated, the table view is reloaded.&lt;/p&gt;

&lt;p&gt;Second, &lt;code&gt;viewWillAppear&lt;/code&gt; is overridden to run &lt;code&gt;startSearch&lt;/code&gt; when the view is displayed only at the first time. &lt;code&gt;autoSearchStarted&lt;/code&gt; flag is used without locking because &lt;code&gt;viewWillAppear&lt;/code&gt; is called only in the main thread.&lt;/p&gt;

&lt;p&gt;Third, &lt;code&gt;UITableViewDataSource&lt;/code&gt; protocol methods are implemented simply using our view model.&lt;/p&gt;

&lt;p&gt;We are ready to run the app. Type &lt;code&gt;Command-R&lt;/code&gt; and check the app appears like the following image. The image view is still not implemented, but the labels are filled with the image meta data.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-09/SwinjectMVVMExampleFilledLabelsScreenshot.png&#34; alt=&#34;SwinjectMVVMExampleFilledLabelsScreenshot&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;unit-tests-for-view-implementation:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Unit Tests for View Implementation&lt;/h3&gt;

&lt;p&gt;To make sure &lt;code&gt;startSearch&lt;/code&gt; on the view model is called only once when the view appears, add the following unit test to &lt;code&gt;ExampleViewTests&lt;/code&gt; group. It uses a mock to count how many times the method is called.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchTableViewControllerSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import ReactiveCocoa
import ExampleViewModel
@testable import ExampleView

class ImageSearchTableViewControllerSpec: QuickSpec {
    // MARK: Mock
    class MockViewModel: ImageSearchTableViewModeling {
        let cellModels = PropertyOf(
            MutableProperty&amp;lt;[ImageSearchTableViewCellModeling]&amp;gt;([]))
        var startSearchCallCount = 0

        func startSearch() {
            startSearchCallCount++
        }
    }

    // MARK: Spec
    override func spec() {
        it(&amp;quot;starts searching images when the view is about to appear at the first time.&amp;quot;) {
            let viewModel = MockViewModel()
            let storyboard = UIStoryboard(
                name: &amp;quot;Main&amp;quot;,
                bundle: NSBundle(forClass: ImageSearchTableViewController.self))
            let viewController = storyboard.instantiateViewControllerWithIdentifier(
                &amp;quot;ImageSearchTableViewController&amp;quot;)
                as! ImageSearchTableViewController
            viewController.viewModel = viewModel

            expect(viewModel.startSearchCallCount) == 0
            viewController.viewWillAppear(true)
            expect(viewModel.startSearchCallCount) == 1
            viewController.viewWillAppear(true)
            expect(viewModel.startSearchCallCount) == 1
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type &lt;code&gt;Command-U&lt;/code&gt; and run the test. Passed!&lt;/p&gt;

&lt;h2 id=&#34;conclusion:8877ce3a4a69e6ded4cb59057183d3db&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We implemented the View and ViewModel parts of the example app. First, the empty implementation of View and ViewModel was added to the project to get working software as the agile practices promote. Then the actual implementation was added. It was demonstrated that the dependencies of Model, View and ViewModel were injected by the application. By adding &lt;code&gt;container&lt;/code&gt; as a property of &lt;code&gt;AppDelegate&lt;/code&gt;, the dependency injection was tested. We learned property types of ReactiveCocoa. &lt;code&gt;MutableProperty&lt;/code&gt; was used as an observable property with its value modifiable. &lt;code&gt;PropertyOf&lt;/code&gt; was used to provide a read-only view to &lt;code&gt;MutableProperty&lt;/code&gt;. In the next blog post, we will implement asynchronous image load feature.&lt;/p&gt;

&lt;p&gt;If you have questions, suggestions or problems, feel free to leave comments.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:8877ce3a4a69e6ded4cb59057183d3db:1&#34;&gt;The instantiation of &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is a bit tricky because &lt;code&gt;UIStoryboard&lt;/code&gt; does not have a normal designated initializer to override by its child classes. To workaround this problem, &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is instantiated with &lt;code&gt;create&lt;/code&gt; function instead of an initializer.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:8877ce3a4a69e6ded4cb59057183d3db:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection in MVVM Architecture with ReactiveCocoa Part 3: Designing the Model</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-3-designing-the-model/</link>
      <pubDate>Mon, 31 Aug 2015 01:10:55 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-3-designing-the-model/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-2-project-setup/&#34;&gt;the last blog post&lt;/a&gt;, we setup an Xcode project to develop an app composed of Model, View and ViewModel frameworks. In this blog post, we are going to develop the Model part in the MVVM architecture. We will learn how to design our Model consisting of entities and services with dependencies injected. Decoupling of the dependencies is the advantage of the MVVM architecture. &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt; is used for event handling, which is essential to decouple Model, View and ViewModel in the MVVM architecture. We will also learn how to use &lt;a href=&#34;https://github.com/ikesyo/Himotoki&#34;&gt;Himotoki&lt;/a&gt; to define mappings from JSON data to Swift types.&lt;/p&gt;

&lt;p&gt;The source code used in the blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenRecord.gif&#34; alt=&#34;SwinjectMVVMExample ScreenRecord&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;notice:10506297541d45beaf70d97ca007d866&#34;&gt;Notice&lt;/h2&gt;

&lt;p&gt;We are going to use Swift 2.0 with Xcode 7 though they are still in beta versions. To use with Swift 2.0, a development version of ReactiveCocoa in &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/tree/swift2&#34;&gt;swift2 branch&lt;/a&gt; will be used. Notice that ReactiveCocoa 3.0 has functional style APIs like &lt;code&gt;|&amp;gt; map&lt;/code&gt; or &lt;code&gt;|&amp;gt; flatMap&lt;/code&gt;, but APIs in swift2 branch are in protocol oriented and fluent style like &lt;code&gt;.map()&lt;/code&gt; or &lt;code&gt;.flatMap()&lt;/code&gt;. Since swift2 branch is still in development, the APIs might be changed in the future.&lt;/p&gt;

&lt;h2 id=&#34;himotoki:10506297541d45beaf70d97ca007d866&#34;&gt;Himotoki&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ikesyo/Himotoki&#34;&gt;Himotoki&lt;/a&gt; is a type-safe JSON decoding library for Swift. It maps JSON elements to properties of a type with a simple definition of the mappings as &lt;code&gt;Decodable&lt;/code&gt; protocol. The advantage of Himotoki is the support of mappings to read-only (&lt;code&gt;let&lt;/code&gt;) properties.&lt;/p&gt;

&lt;p&gt;Its usage is simple. Assume that you want to map JSON like &lt;code&gt;{ &amp;quot;some_name&amp;quot;: &amp;quot;Himotoki&amp;quot;, &amp;quot;some_value&amp;quot;: 1 }&lt;/code&gt; to &lt;code&gt;SomeValue&lt;/code&gt; type. To define the mappings, make &lt;code&gt;SomeValue&lt;/code&gt; type conform &lt;code&gt;Decodable&lt;/code&gt; protocol.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct SomeValue {
    let name: String
    let value: Int
}

extension SomeValue: Decodable {
    static func decode(e: Extractor) -&amp;gt; Group? {
        return build(SomeValue.init)(
            e &amp;lt;| &amp;quot;some_name&amp;quot;,
            e &amp;lt;| &amp;quot;some_value&amp;quot;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;decode&lt;/code&gt; function, the mappings are defined as the parameters to &lt;code&gt;build&lt;/code&gt; function. Here &lt;code&gt;some_name&lt;/code&gt; is mapped to &lt;code&gt;name&lt;/code&gt; property of &lt;code&gt;SomeValue&lt;/code&gt;, and &lt;code&gt;some_value&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; property. The mappings are defined in the order as the properties of &lt;code&gt;SomeValue&lt;/code&gt; type are defined.&lt;/p&gt;

&lt;p&gt;To get an instance mapped from JSON data, call &lt;code&gt;decode&lt;/code&gt; function with JSON data as &lt;code&gt;[String: AnyObject]&lt;/code&gt; returned from Alamofire or NSJSONSerialization.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testSomeValue() {
    // JSON data returned from Alamofire or NSJSONSerialization.
    let json: [String: AnyObject] = [&amp;quot;some_name&amp;quot;: &amp;quot;Himotoki&amp;quot;, &amp;quot;some_value&amp;quot;: 1]

    let v: SomeValue? = decode(json)
    XCTAssert(v != nil)
    XCTAssert(v?.name == &amp;quot;Himotoki&amp;quot;)
    XCTAssert(v?.value == 1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Himotoki, you can reduce the code to handle JSON data&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10506297541d45beaf70d97ca007d866:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:10506297541d45beaf70d97ca007d866:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. It also supports nested data, optional parameters and more. Refer to &lt;a href=&#34;https://github.com/ikesyo/Himotoki&#34;&gt;the project page&lt;/a&gt; for the details.&lt;/p&gt;

&lt;h2 id=&#34;pixabay-api-spec:10506297541d45beaf70d97ca007d866&#34;&gt;Pixabay API Spec&lt;/h2&gt;

&lt;p&gt;According to &lt;a href=&#34;https://pixabay.com/api/docs/&#34;&gt;the API documentation of Pixabay&lt;/a&gt;, a JSON response from Pixabay server is in the following format. It contains an array of image information (&lt;code&gt;hits&lt;/code&gt;), and the numbers of total images (&lt;code&gt;total&lt;/code&gt;) and available images (&lt;code&gt;totalHits&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;total&amp;quot;: 12274,
    &amp;quot;totalHits&amp;quot;: 240,
    &amp;quot;hits&amp;quot;: [
        {
            &amp;quot;id&amp;quot;: 11574,
            &amp;quot;pageURL&amp;quot;: &amp;quot;https://pixabay.com/en/sonnenblumen-sonnenblumenfeld-flora-11574/&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;photo&amp;quot;,
            &amp;quot;tags&amp;quot;: &amp;quot;sunflower, sunflower field, flora&amp;quot;,
            &amp;quot;previewURL&amp;quot;: &amp;quot;https://pixabay.com/static/uploads/photo/2012/01/07/21/56/sunflower-11574_150.jpg&amp;quot;,
            &amp;quot;previewWidth&amp;quot;: 150,
            &amp;quot;previewHeight&amp;quot;: 92,
            &amp;quot;webformatURL&amp;quot;: &amp;quot;https://pixabay.com/get/3b4f5d71752e6ce9cbcf/1356479243/aca42219d23fd9fe0cc6f1cc_640.jpg&amp;quot;,
            &amp;quot;webformatWidth&amp;quot;: 640,
            &amp;quot;webformatHeight&amp;quot;: 396,
            &amp;quot;imageWidth&amp;quot;: 1280,
            &amp;quot;imageHeight&amp;quot;: 792,
            &amp;quot;views&amp;quot;: 10928,
            &amp;quot;downloads&amp;quot;: 1649,
            &amp;quot;likes&amp;quot;: 70,
            &amp;quot;user&amp;quot;: &amp;quot;WikiImages&amp;quot;
        },
        {
            &amp;quot;id&amp;quot;: &amp;quot;256&amp;quot;,
            &amp;quot;pageURL&amp;quot;: &amp;quot;https://pixabay.com/en/example-image-256/&amp;quot;,
            &amp;quot;type&amp;quot;: &amp;quot;photo&amp;quot;,
            // ... etc.
        },
        //... 18 more hits for page number 1
    ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;model-design-overview:10506297541d45beaf70d97ca007d866&#34;&gt;Model Design Overview&lt;/h2&gt;

&lt;p&gt;We are going to design our Model to be composed of entities and services. In short, an entity is a concept or object that exists in a model&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10506297541d45beaf70d97ca007d866:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:10506297541d45beaf70d97ca007d866:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. A service is a stateless operation that does not fit in an entity.&lt;/p&gt;

&lt;p&gt;To decouple ViewModel and Model, and Model and external system, the interfaces are defined by protocols. In the diagram below, &lt;code&gt;ImageSearching&lt;/code&gt; and &lt;code&gt;Networking&lt;/code&gt; are protocols. &lt;code&gt;ImageSearch&lt;/code&gt; and &lt;code&gt;Network&lt;/code&gt; are their implementations conforming the protocols. &lt;code&gt;ViewModel&lt;/code&gt; accesses &lt;code&gt;Model&lt;/code&gt; through &lt;code&gt;ImageSearching&lt;/code&gt; protocol, and its implementation &lt;code&gt;ImageSearch&lt;/code&gt; accesses the external system through &lt;code&gt;Networking&lt;/code&gt; protocol. The external system raises events with JSON data. The data are converted to &lt;code&gt;ResponseEntity&lt;/code&gt; and &lt;code&gt;ImageEntity&lt;/code&gt; by &lt;code&gt;ImageSearch&lt;/code&gt; when the events are propagated to &lt;code&gt;ViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleModelDesign.png&#34; alt=&#34;Model Design&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;entities:10506297541d45beaf70d97ca007d866&#34;&gt;Entities&lt;/h2&gt;

&lt;p&gt;In this section, we are going to define the entities representing an image and response obtained from Pixabay. Add &lt;code&gt;ImageEntity.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModel&lt;/code&gt; target. To make sure the file is added to the target, right click on &lt;code&gt;ExampleModel&lt;/code&gt; group (folder icon) in Project Navigator, and choose &lt;code&gt;New File...&lt;/code&gt; then &lt;code&gt;Swift File&lt;/code&gt;. When Xcode asks targets to add the file to, check only &lt;code&gt;ExampleModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageEntity.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Himotoki

public struct ImageEntity {
    public let id: UInt64

    public let pageURL: String
    public let pageImageWidth: Int
    public let pageImageHeight: Int

    public let previewURL: String
    public let previewWidth: Int
    public let previewHeight: Int

    public let imageURL: String
    public let imageWidth: Int
    public let imageHeight: Int

    public let viewCount: Int64
    public let downloadCount: Int64
    public let likeCount: Int64
    public let tags: [String]
    public let username: String
}

// MARK: Decodable
extension ImageEntity: Decodable {
    public static func decode(e: Extractor) -&amp;gt; ImageEntity? {
        let splitCSV: String -&amp;gt; [String] = { csv in
            csv.characters
                .split { $0 == &amp;quot;,&amp;quot; }
                .map {
                    String($0).stringByTrimmingCharactersInSet(
                        NSCharacterSet.whitespaceCharacterSet())
                }
        }

        return build(ImageEntity.init)(
            e &amp;lt;| &amp;quot;id&amp;quot;,

            e &amp;lt;| &amp;quot;pageURL&amp;quot;,
            e &amp;lt;| &amp;quot;imageWidth&amp;quot;,
            e &amp;lt;| &amp;quot;imageHeight&amp;quot;,

            e &amp;lt;| &amp;quot;previewURL&amp;quot;,
            e &amp;lt;| &amp;quot;previewWidth&amp;quot;,
            e &amp;lt;| &amp;quot;previewHeight&amp;quot;,

            e &amp;lt;| &amp;quot;webformatURL&amp;quot;,
            e &amp;lt;| &amp;quot;webformatWidth&amp;quot;,
            e &amp;lt;| &amp;quot;webformatHeight&amp;quot;,

            e &amp;lt;| &amp;quot;views&amp;quot;,
            e &amp;lt;| &amp;quot;downloads&amp;quot;,
            e &amp;lt;| &amp;quot;likes&amp;quot;,
            (e &amp;lt;| &amp;quot;tags&amp;quot;).map(splitCSV) ?? [],
            e &amp;lt;| &amp;quot;user&amp;quot;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that &lt;code&gt;ImageEntity&lt;/code&gt; is defined as a &lt;code&gt;struct&lt;/code&gt; with its properties immutable. The immutability keeps the users of the entity safe&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10506297541d45beaf70d97ca007d866:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:10506297541d45beaf70d97ca007d866:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. Accessibility of the type is &lt;code&gt;public&lt;/code&gt; because it is referenced from &lt;code&gt;ExampleViewModel&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;Some properties of &lt;code&gt;ImageEntity&lt;/code&gt; are named differently from the JSON elements to match Swift naming convention and our app. The properties &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;viewCount&lt;/code&gt;, &lt;code&gt;downloadCount&lt;/code&gt; and &lt;code&gt;likeCount&lt;/code&gt; are declared as &lt;code&gt;UInt64&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt; to ensure they accept large values even in 32-bit system. JSON element &lt;code&gt;tags&lt;/code&gt; as a &lt;a href=&#34;https://en.wikipedia.org/wiki/Comma-separated_values&#34;&gt;CSV&lt;/a&gt; format string is mapped to an array of split strings by &lt;code&gt;(e &amp;lt;| &amp;quot;tags&amp;quot;).map(splitCSV)&lt;/code&gt;. By applying &lt;code&gt;?? []&lt;/code&gt; to the returned value, an empty array is used if the &lt;code&gt;tags&lt;/code&gt; is nil.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;ResponseEntity.swift&lt;/code&gt; to &lt;code&gt;ExampleModel&lt;/code&gt; target with the following text contents. Here &lt;code&gt;&amp;lt;||&lt;/code&gt; operator is used to map an array. The &lt;code&gt;total&lt;/code&gt; element in the JSON is ignored. If we find it is necessary, we can add it later.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ResponseEntity.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Himotoki

public struct ResponseEntity {
    public let totalCount: Int64
    public let images: [ImageEntity]
}

// MARK: Decodable
extension ResponseEntity: Decodable {
    public static func decode(e: Extractor) -&amp;gt; ResponseEntity? {
        return build(ResponseEntity.init)(
            e &amp;lt;| &amp;quot;totalHits&amp;quot;,
            e &amp;lt;|| &amp;quot;hits&amp;quot;
        )
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To test &lt;code&gt;ImageEntity&lt;/code&gt;, add &lt;code&gt;Dummy.swift&lt;/code&gt; and &lt;code&gt;ImageEntitySpec.swift&lt;/code&gt; with the following contents to &lt;code&gt;ExampleModelTests&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dummy.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let imageJSON: [String: AnyObject] = [
    &amp;quot;id&amp;quot;: 12345,
    &amp;quot;pageURL&amp;quot;: &amp;quot;https://somewhere.com/page/&amp;quot;,
    &amp;quot;imageWidth&amp;quot;: 2000,
    &amp;quot;imageHeight&amp;quot;: 1000,
    &amp;quot;previewURL&amp;quot;: &amp;quot;https://somewhere.com/preview.jpg&amp;quot;,
    &amp;quot;previewWidth&amp;quot;: 200,
    &amp;quot;previewHeight&amp;quot;: 100,
    &amp;quot;webformatURL&amp;quot;: &amp;quot;https://somewhere.com/image.jpg&amp;quot;,
    &amp;quot;webformatWidth&amp;quot;: 600,
    &amp;quot;webformatHeight&amp;quot;: 300,
    &amp;quot;views&amp;quot;: 54321,
    &amp;quot;downloads&amp;quot;: 4321,
    &amp;quot;likes&amp;quot;: 321,
    &amp;quot;tags&amp;quot;: &amp;quot;a, b c, d &amp;quot;,
    &amp;quot;user&amp;quot;: &amp;quot;Swinject&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;ImageEntitySpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Himotoki
@testable import ExampleModel

class ImageEntitySpec: QuickSpec {
    override func spec() {
        it(&amp;quot;parses JSON data to create a new instance.&amp;quot;) {
            let image: ImageEntity? = decode(imageJSON)

            expect(image).notTo(beNil())
            expect(image?.id) == 12345
            expect(image?.pageURL) == &amp;quot;https://somewhere.com/page/&amp;quot;
            expect(image?.pageImageWidth) == 2000
            expect(image?.pageImageHeight) == 1000
            expect(image?.previewURL) == &amp;quot;https://somewhere.com/preview.jpg&amp;quot;
            expect(image?.previewWidth) == 200
            expect(image?.previewHeight) == 100
            expect(image?.imageURL) == &amp;quot;https://somewhere.com/image.jpg&amp;quot;
            expect(image?.imageWidth) == 600
            expect(image?.imageHeight) == 300
            expect(image?.viewCount) == 54321
            expect(image?.downloadCount) == 4321
            expect(image?.likeCount) == 321
            expect(image?.tags) == [&amp;quot;a&amp;quot;, &amp;quot;b c&amp;quot;, &amp;quot;d&amp;quot;]
            expect(image?.username) == &amp;quot;Swinject&amp;quot;
        }
        it(&amp;quot;gets an empty array if tags element is nil.&amp;quot;) {
            var missingJSON = imageJSON
            missingJSON[&amp;quot;tags&amp;quot;] = nil
            let image: ImageEntity? = decode(missingJSON)

            expect(image).notTo(beNil())
            expect(image?.tags.isEmpty).to(beTrue())
        }
        it(&amp;quot;gets nil if any of JSON elements except tags is missing.&amp;quot;) {
            for key in imageJSON.keys where key != &amp;quot;tags&amp;quot; {
                var missingJSON = imageJSON
                missingJSON[key] = nil
                let image: ImageEntity? = decode(missingJSON)

                expect(image).to(beNil())
            }
        }
        it(&amp;quot;ignores an extra JOSN element.&amp;quot;) {
            var extraJSON = imageJSON
            extraJSON[&amp;quot;extraKey&amp;quot;] = &amp;quot;extra element&amp;quot;
            let image: ImageEntity? = decode(extraJSON)

            expect(image).notTo(beNil())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;Dummy.swift&lt;/code&gt;, a dummy instance of JSON data is defined as &lt;code&gt;imageJSON&lt;/code&gt;. Since Himotoki handles JSON data as &lt;code&gt;[String: AnyObject]&lt;/code&gt; type returned from Alamofire or NSJSONSerialization, &lt;code&gt;imageJSON&lt;/code&gt; is defined as &lt;code&gt;[String: AnyObject]&lt;/code&gt;, not as &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;it(&amp;quot;parses JSON data to create a new instance.&amp;quot;)&lt;/code&gt; checks that all the properties of &lt;code&gt;ImageEntity&lt;/code&gt; are mapped from the JSON data.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;it(&amp;quot;gets an empty array if tags element is nil.&amp;quot;)&lt;/code&gt; checks that &lt;code&gt;tags&lt;/code&gt; property is set to an empty array if &lt;code&gt;tags&lt;/code&gt; element is missing in the JSON data.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;it(&amp;quot;gets nil if any of JSON elements except tags is missing.&amp;quot;)&lt;/code&gt; checks that &lt;code&gt;decode&lt;/code&gt; function returns &lt;code&gt;nil&lt;/code&gt; if any of the JSON elements except &lt;code&gt;tags&lt;/code&gt; is missing. Incorrect or broken JSON data can be detected to see whether the returned value is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;it(&amp;quot;ignores an extra JOSN element.&amp;quot;)&lt;/code&gt; checks that &lt;code&gt;decode&lt;/code&gt; function returns an &lt;code&gt;ImageEntity&lt;/code&gt; instance even if an extra JSON element exists. Ignoring extra elements, our JSON mapping is stable for future changes on the Pixabay API.&lt;/p&gt;

&lt;p&gt;Next add &lt;code&gt;ResponseEntitySpec.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModelTests&lt;/code&gt; target. The test is simple as you see.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ResponseEntitySpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Himotoki
@testable import ExampleModel

class ResponseEntitySpec: QuickSpec {
    override func spec() {
        let json: [String: AnyObject] = [
            &amp;quot;totalHits&amp;quot;: 123,
            &amp;quot;hits&amp;quot;: [imageJSON, imageJSON]
        ]

        it(&amp;quot;parses JSON data to create a new instance.&amp;quot;) {
            let response: ResponseEntity? = decode(json)

            expect(response).notTo(beNil())
            expect(response?.totalCount) == 123
            expect(response?.images.count) == 2
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type &lt;code&gt;Command-U&lt;/code&gt; to run the unit tests. Passed. The tests passed without any problems, but, in actual development, we iterate fixing the entities and tests until the tests pass.&lt;/p&gt;

&lt;h2 id=&#34;network-service:10506297541d45beaf70d97ca007d866&#34;&gt;Network Service&lt;/h2&gt;

&lt;p&gt;As we did in &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the simple weather app example&lt;/a&gt;, we are going to encapsulate Alamofire within &lt;code&gt;Network&lt;/code&gt; type conforming &lt;code&gt;Networking&lt;/code&gt; protocol. This time, we use ReactiveCocoa to handle the network event. Add &lt;code&gt;Networking.swift&lt;/code&gt; and &lt;code&gt;Network.swift&lt;/code&gt; with the following contents to &lt;code&gt;ExampleModel&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Networking.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa

public protocol Networking {
    func requestJSON(url: String, parameters: [String : AnyObject]?)
        -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Network.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa
import Alamofire

public final class Network: Networking {
    private let queue = dispatch_queue_create(
        &amp;quot;SwinjectMMVMExample.ExampleModel.Network.Queue&amp;quot;,
        DISPATCH_QUEUE_SERIAL)

    public init() { }

    public func requestJSON(url: String, parameters: [String : AnyObject]?)
        -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
    {
        return SignalProducer { observer, disposable in
            let serializer = Alamofire.Request.JSONResponseSerializer()
            Alamofire.request(.GET, url, parameters: parameters)
                .response(queue: self.queue, responseSerializer: serializer) {
                    _, _, result in
                    switch result {
                    case .Success(let value):
                        sendNext(observer, value)
                        sendCompleted(observer)
                    case .Failure(_, let error):
                        sendError(observer, NetworkError(error: error))
                    }
                }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the previous example&lt;/a&gt;, the network service took a callback to pass a response. This time, &lt;code&gt;requestJSON&lt;/code&gt; method returns &lt;code&gt;SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;&lt;/code&gt; to deliver network events to its observer. The &lt;code&gt;SignalProducer&lt;/code&gt; takes a generic argument as &lt;code&gt;AnyObject&lt;/code&gt; because Alamofire (or NSJSONSerialization) returns JSON data as &lt;code&gt;AnyObject&lt;/code&gt; that is actually an array or dictionary.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;requestJSON&lt;/code&gt; method creates &lt;code&gt;SignalProducer&lt;/code&gt; instance with its trailing closure, and returns the instance. Within the closure, a response event of Alamofire is converted to a ReactiveCocoa event by calling &lt;code&gt;sendNext&lt;/code&gt;, &lt;code&gt;sendCompleted&lt;/code&gt; and &lt;code&gt;sendError&lt;/code&gt;. Notice that the closure passed to &lt;code&gt;SignalProducer&lt;/code&gt; is not actually invoked until &lt;code&gt;start&lt;/code&gt; method is called on the &lt;code&gt;SignalProducer&lt;/code&gt; instance.&lt;/p&gt;

&lt;p&gt;A dispatch queue is passed to Alamofire to run the response in a background thread because Alamofire by default runs the response in the main thread (main queue).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sendError&lt;/code&gt; function takes an instance of &lt;code&gt;NetworkError&lt;/code&gt; type. Add &lt;code&gt;NetworkError.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModel&lt;/code&gt; target. It converts an &lt;code&gt;NSError&lt;/code&gt; passed from Alamofire to our own error type&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:10506297541d45beaf70d97ca007d866:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:10506297541d45beaf70d97ca007d866:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NetworkError.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

public enum NetworkError: ErrorType {
    /// Unknown or not supported error.
    case Unknown

    /// Not connected to the internet.
    case NotConnectedToInternet

    /// International data roaming turned off.
    case InternationalRoamingOff

    /// Cannot reach the server.
    case NotReachedServer

    /// Connection is lost.
    case ConnectionLost

    /// Incorrect data returned from the server.
    case IncorrectDataReturned

    internal init(error: ErrorType) {
        let nsError = error as NSError
        if nsError.domain == NSURLErrorDomain {
            switch nsError.code {
            case NSURLErrorUnknown:
                self = .Unknown
            case NSURLErrorCancelled:
                self = .Unknown // Cancellation is not used in this project.
            case NSURLErrorBadURL:
                self = .IncorrectDataReturned // Because it is caused by a bad URL returned in a JSON response from the server.
            case NSURLErrorTimedOut:
                self = .NotReachedServer
            case NSURLErrorUnsupportedURL:
                self = .IncorrectDataReturned
            case NSURLErrorCannotFindHost, NSURLErrorCannotConnectToHost:
                self = .NotReachedServer
            case NSURLErrorDataLengthExceedsMaximum:
                self = .IncorrectDataReturned
            case NSURLErrorNetworkConnectionLost:
                self = .ConnectionLost
            case NSURLErrorDNSLookupFailed:
                self = .NotReachedServer
            case NSURLErrorHTTPTooManyRedirects:
                self = .Unknown
            case NSURLErrorResourceUnavailable:
                self = .IncorrectDataReturned
            case NSURLErrorNotConnectedToInternet:
                self = .NotConnectedToInternet
            case NSURLErrorRedirectToNonExistentLocation, NSURLErrorBadServerResponse:
                self = .IncorrectDataReturned
            case NSURLErrorUserCancelledAuthentication, NSURLErrorUserAuthenticationRequired:
                self = .Unknown
            case NSURLErrorZeroByteResource, NSURLErrorCannotDecodeRawData, NSURLErrorCannotDecodeContentData:
                self = .IncorrectDataReturned
            case NSURLErrorCannotParseResponse:
                self = .IncorrectDataReturned
            case NSURLErrorInternationalRoamingOff:
                self = .InternationalRoamingOff
            case NSURLErrorCallIsActive, NSURLErrorDataNotAllowed, NSURLErrorRequestBodyStreamExhausted:
                self = .Unknown
            case NSURLErrorFileDoesNotExist, NSURLErrorFileIsDirectory:
                self = .IncorrectDataReturned
            case
            NSURLErrorNoPermissionsToReadFile,
            NSURLErrorSecureConnectionFailed,
            NSURLErrorServerCertificateHasBadDate,
            NSURLErrorServerCertificateUntrusted,
            NSURLErrorServerCertificateHasUnknownRoot,
            NSURLErrorServerCertificateNotYetValid,
            NSURLErrorClientCertificateRejected,
            NSURLErrorClientCertificateRequired,
            NSURLErrorCannotLoadFromNetwork,
            NSURLErrorCannotCreateFile,
            NSURLErrorCannotOpenFile,
            NSURLErrorCannotCloseFile,
            NSURLErrorCannotWriteToFile,
            NSURLErrorCannotRemoveFile,
            NSURLErrorCannotMoveFile,
            NSURLErrorDownloadDecodingFailedMidStream,
            NSURLErrorDownloadDecodingFailedToComplete:
                self = .Unknown
            default:
                self = .Unknown
            }
        }
        else {
            self = .Unknown
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add unit tests for the &lt;code&gt;Network&lt;/code&gt; type. Add &lt;code&gt;NetworkSpec.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModelTests&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NetworkSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
@testable import ExampleModel

class NetworkSpec: QuickSpec {
    override func spec() {
        var network: Network!
        beforeEach {
            network = Network()
        }

        describe(&amp;quot;JSON&amp;quot;) {
            it(&amp;quot;eventually gets JSON data as specified with parameters.&amp;quot;) {
                var json: [String: AnyObject]? = nil
                let url = &amp;quot;https://httpbin.org/get&amp;quot;
                network.requestJSON(url, parameters: [&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;x&amp;quot;: &amp;quot;y&amp;quot;])
                    .on(next: { json = $0 as? [String: AnyObject] })
                    .start()

                expect(json).toEventuallyNot(beNil(), timeout: 5)
                expect((json?[&amp;quot;args&amp;quot;] as? [String: AnyObject])?[&amp;quot;a&amp;quot;] as? String)
                    .toEventually(equal(&amp;quot;b&amp;quot;), timeout: 5)
                expect((json?[&amp;quot;args&amp;quot;] as? [String: AnyObject])?[&amp;quot;x&amp;quot;] as? String)
                    .toEventually(equal(&amp;quot;y&amp;quot;), timeout: 5)
            }
            it(&amp;quot;eventually gets an error if the network has a problem.&amp;quot;) {
                var error: NetworkError? = nil
                let url = &amp;quot;https://not.existing.server.comm/get&amp;quot;
                network.requestJSON(url, parameters: [&amp;quot;a&amp;quot;: &amp;quot;b&amp;quot;, &amp;quot;x&amp;quot;: &amp;quot;y&amp;quot;])
                    .on(error: { error = $0 })
                    .start()

                expect(error)
                    .toEventually(equal(NetworkError.NotReachedServer), timeout: 5)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here &lt;a href=&#34;https://httpbin.org/&#34;&gt;httpbin.org&lt;/a&gt; is used as a stable and simple server to test the network. It is used by &lt;a href=&#34;https://github.com/Alamofire/Alamofire/blob/1978c2c926b0eabedc858d4cde0533e00686ccd6/Tests/ResponseTests.swift&#34;&gt;the unit tests of Alamofire&lt;/a&gt; too. Access &lt;a href=&#34;https://httpbin.org/get?a=b&amp;amp;x=y&#34;&gt;https://httpbin.org/get?a=b&amp;amp;x=y&lt;/a&gt; with a browser, and you will see how it works.&lt;/p&gt;

&lt;p&gt;The first test checks the JSON response has &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;x&amp;quot;&lt;/code&gt; elements with &lt;code&gt;&amp;quot;b&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;y&amp;quot;&lt;/code&gt; values as specified in the request parameters. &lt;code&gt;json&lt;/code&gt; parameter is used to store the response from the server asynchronously. To add an observer (namely an event handler) to the &lt;code&gt;SignalProducer&lt;/code&gt; returned from &lt;code&gt;requestJSON&lt;/code&gt;, &lt;code&gt;on&lt;/code&gt; method is used with a closure to set the &lt;code&gt;json&lt;/code&gt; response. Then &lt;code&gt;start&lt;/code&gt; is called to get the &lt;code&gt;SignalProducer&lt;/code&gt; initiating its signal. The response is checked asynchronously with &lt;code&gt;toEventually&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;The second test checks &lt;code&gt;NetworkError&lt;/code&gt; is sent in case of an error. To emulate an error, a URL that does not exist is passed to &lt;code&gt;requestJSON&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Run the unit tests, and let&amp;rsquo;s move on to the next section.&lt;/p&gt;

&lt;h2 id=&#34;image-search-service:10506297541d45beaf70d97ca007d866&#34;&gt;Image Search Service&lt;/h2&gt;

&lt;p&gt;In this section, we are going to define the service to search images through Pixabay API. This is the main part of &lt;code&gt;ExampleModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First, add &lt;code&gt;Pixabay.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModel&lt;/code&gt; target. It defines the URL and parameters for the API. Please fill &lt;code&gt;apiUsername&lt;/code&gt; and &lt;code&gt;apiKey&lt;/code&gt; with &lt;a href=&#34;https://pixabay.com/api/docs/&#34;&gt;your own username and API key obtained from Pixabay&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pixabay.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;internal struct Pixabay {
    internal static let apiURL = &amp;quot;https://pixabay.com/api/&amp;quot;

    internal static var requestParameters: [String: AnyObject] {
        return [
            &amp;quot;username&amp;quot;: Config.apiUsername,
            &amp;quot;key&amp;quot;: Config.apiKey,
            &amp;quot;image_type&amp;quot;: &amp;quot;photo&amp;quot;,
            &amp;quot;safesearch&amp;quot;: true,
            &amp;quot;per_page&amp;quot;: 50,
        ]
    }
}

extension Pixabay {
    private struct Config {
        private static let apiUsername = &amp;quot;&amp;quot; // Fill with your own username.
        private static let apiKey = &amp;quot;&amp;quot; // Fill with your own API key.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, add &lt;code&gt;ImageSearching.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModel&lt;/code&gt; target. The protocol has &lt;code&gt;searchImages&lt;/code&gt; method returning &lt;code&gt;SignalProducer&lt;/code&gt; of &lt;code&gt;ResponseEntity&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearching.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa

public protocol ImageSearching {
    func searchImages() -&amp;gt; SignalProducer&amp;lt;ResponseEntity, NetworkError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Third, add &lt;code&gt;ImageSearch.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModel&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearch.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import ReactiveCocoa
import Result
import Himotoki

public final class ImageSearch: ImageSearching {
    private let network: Networking

    public init(network: Networking) {
        self.network = network
    }

    public func searchImages() -&amp;gt; SignalProducer&amp;lt;ResponseEntity, NetworkError&amp;gt; {
        let url = Pixabay.apiURL
        let parameters = Pixabay.requestParameters
        return network.requestJSON(url, parameters: parameters)
            .attemptMap { json in
                if let response = decode(json) as ResponseEntity? {
                    return Result(value: response)
                }
                else {
                    return Result(error: .IncorrectDataReturned)
                }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ImageSearch&lt;/code&gt; has dependency on &lt;code&gt;Networking&lt;/code&gt; injected through the initializer as &lt;a href=&#34;https://github.com/Swinject/Swinject/blob/master/Documentation/InjectionPatterns.md&#34;&gt;initializer injection pattern&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;searchImages&lt;/code&gt; method converts &lt;code&gt;SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;&lt;/code&gt; returned from &lt;code&gt;network.requestJSON&lt;/code&gt; to &lt;code&gt;SignalProducer&amp;lt;ResponseEntity, NetworkError&amp;gt;&lt;/code&gt;. To convert the &lt;code&gt;SignalProducer&lt;/code&gt;, &lt;code&gt;attemptMap&lt;/code&gt; is used. The closure passed to &lt;code&gt;attemptMap&lt;/code&gt; calls &lt;code&gt;decode&lt;/code&gt; to map the JSON data to a &lt;code&gt;ResponseEntity&lt;/code&gt; instance. If the mapping succeeds, the mapped response is returned as &lt;code&gt;Result(value: response)&lt;/code&gt;. Otherwise, an error is returned as &lt;code&gt;Result(error: .IncorrectDataReturned)&lt;/code&gt;. If you convert a value not to an error but to another value only, you can just use &lt;code&gt;map&lt;/code&gt; method on &lt;code&gt;SignalProducer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The cast of &lt;code&gt;decode(json) as ResponseEntity?&lt;/code&gt; looks irregular, but it helps Swift compiler infer that &lt;code&gt;decode&lt;/code&gt; function on &lt;code&gt;ResponseEntity&lt;/code&gt; type should be used. If the cast is &lt;code&gt;decode(json) as? ResponseEntity&lt;/code&gt;, the source code cannot be compiled.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s write unit tests. Add &lt;code&gt;ImageSearchSpec.swift&lt;/code&gt; with the following content to &lt;code&gt;ExampleModelTests&lt;/code&gt; target.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ImageSearchSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import ReactiveCocoa
@testable import ExampleModel

class ImageSearchSpec: QuickSpec {
    // MARK: Stub
    class GoodStubNetwork: Networking {
        func requestJSON(url: String, parameters: [String : AnyObject]?)
            -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
        {
            var imageJSON0 = imageJSON
            imageJSON0[&amp;quot;id&amp;quot;] = 0
            var imageJSON1 = imageJSON
            imageJSON1[&amp;quot;id&amp;quot;] = 1
            let json: [String: AnyObject] = [
                &amp;quot;totalHits&amp;quot;: 123,
                &amp;quot;hits&amp;quot;: [imageJSON0, imageJSON1]
            ]

            return SignalProducer { observer, disposable in
                sendNext(observer, json)
                sendCompleted(observer)
            }.observeOn(QueueScheduler())
        }
    }

    class BadStubNetwork: Networking {
        func requestJSON(url: String, parameters: [String : AnyObject]?)
            -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
        {
            let json = [String: AnyObject]()

            return SignalProducer { observer, disposable in
                sendNext(observer, json)
                sendCompleted(observer)
            }.observeOn(QueueScheduler())
        }
    }

    class ErrorStubNetwork: Networking {
        func requestJSON(url: String, parameters: [String : AnyObject]?)
            -&amp;gt; SignalProducer&amp;lt;AnyObject, NetworkError&amp;gt;
        {
            return SignalProducer { observer, disposable in
                sendError(observer, .NotConnectedToInternet)
            }.observeOn(QueueScheduler())
        }
    }

    // MARK: - Spec
    override func spec() {
        it(&amp;quot;returns images if the network works correctly.&amp;quot;) {
            var response: ResponseEntity? = nil
            let search = ImageSearch(network: GoodStubNetwork())
            search.searchImages()
                .on(next: { response = $0 })
                .start()

            expect(response).toEventuallyNot(beNil())
            expect(response?.totalCount).toEventually(equal(123))
            expect(response?.images.count).toEventually(equal(2))
            expect(response?.images[0].id).toEventually(equal(0))
            expect(response?.images[1].id).toEventually(equal(1))
        }
        it(&amp;quot;sends an error if the network returns incorrect data.&amp;quot;) {
            var error: NetworkError? = nil
            let search = ImageSearch(network: BadStubNetwork())
            search.searchImages()
                .on(error: { error = $0 })
                .start()

            expect(error).toEventually(equal(NetworkError.IncorrectDataReturned))
        }
        it(&amp;quot;passes the error sent by the network.&amp;quot;) {
            var error: NetworkError? = nil
            let search = ImageSearch(network: ErrorStubNetwork())
            search.searchImages()
                .on(error: { error = $0 })
                .start()

            expect(error).toEventually(equal(NetworkError.NotConnectedToInternet))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the beginning, three stubs are defined. &lt;code&gt;GoodStubNetwork&lt;/code&gt; returns a &lt;code&gt;SignalProducer&lt;/code&gt; that sends correct JSON data. &lt;code&gt;BadStubNetwork&lt;/code&gt; returns a &lt;code&gt;SignalProducer&lt;/code&gt; that sends incorrect JSON data as an empty dictionary. &lt;code&gt;ErrorStubNetwork&lt;/code&gt; returns a &lt;code&gt;SignalProducer&lt;/code&gt; that does not send JSON data but an error. All the &lt;code&gt;SignalProducer&lt;/code&gt;s send the events in a background thread emulating an asynchronous network response by specifying &lt;code&gt;.observeOn(QueueScheduler())&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;spec()&lt;/code&gt;, three unit tests (or specs) are defined. The first one checks the case that &lt;code&gt;attemptMap&lt;/code&gt; successfully converts JSON data to a &lt;code&gt;ResponseEntity&lt;/code&gt;. The second one checks the case that &lt;code&gt;attemptMap&lt;/code&gt; converts JSON data to an error. The third one checks the case that the error sent from &lt;code&gt;ErrorStubNetwork&lt;/code&gt; is passed through &lt;code&gt;ImageSearch&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Type &lt;code&gt;Command-U&lt;/code&gt; to run the tests. Passed! We finished implementing the main part of our model in MVVM architecture.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:10506297541d45beaf70d97ca007d866&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Through the development of the Model part of the example app in MVVM architecture, we learned how to design the Model to decouple from ViewModel and the external system. Protocols were used to remove the direct dependencies on the implementations. ReactiveCocoa was used to handle events between the decoupled components. Also we found Himotoki was helpful to map JSON data to our entities. In the next blog post, we will design and implement View and ViewModel parts.&lt;/p&gt;

&lt;p&gt;If you have questions, suggestions or problems, feel free to leave comments.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:10506297541d45beaf70d97ca007d866:1&#34;&gt;If you are familiar with &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_programming&#34;&gt;functional programming&lt;/a&gt;, &lt;a href=&#34;https://github.com/thoughtbot/Argo&#34;&gt;Argo&lt;/a&gt; is also a good choice for a JSON parser.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10506297541d45beaf70d97ca007d866:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10506297541d45beaf70d97ca007d866:2&#34;&gt;In &lt;a href=&#34;https://en.wikipedia.org/wiki/Domain-driven_design&#34;&gt;DDD (Domain-Driven Design)&lt;/a&gt;, an entity is a concept of a domain model and is defined by its identity. In our project, the term is used to mean just a concept or object regardless of its identity.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10506297541d45beaf70d97ca007d866:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10506297541d45beaf70d97ca007d866:3&#34;&gt;Refer to &lt;a href=&#34;http://programmers.stackexchange.com/questions/151733/if-immutable-objects-are-good-why-do-people-keep-creating-mutable-objects&#34;&gt;this page&lt;/a&gt; to know more about immutability and mutability.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10506297541d45beaf70d97ca007d866:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:10506297541d45beaf70d97ca007d866:4&#34;&gt;&amp;ldquo;&lt;a href=&#34;https://realm.io/news/testing-swift-error-type/&#34;&gt;How to Implement the ErrorType Protocol&lt;/a&gt;&amp;rdquo; is worth reading about &lt;code&gt;ErrorType&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:10506297541d45beaf70d97ca007d866:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection in MVVM Architecture with ReactiveCocoa Part 2: Project Setup</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-2-project-setup/</link>
      <pubDate>Sat, 29 Aug 2015 10:00:28 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-2-project-setup/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-1-introduction/&#34;&gt;the last blog post&lt;/a&gt;, the basic concepts of MVVM (Model-View-ViewModel) and &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt; were introduced. From this blog post, we are going to develop an example app to demonstrate dependency injection with &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt; in MVVM architecture. We will use ReactiveCococa to handle events passed between MVVM components. In this blog post, you will learn how to setup an Xcode project composing Molel, View and ViewModel as  frameworks.&lt;/p&gt;

&lt;p&gt;The example app asynchronously searches, downloads and displays images obtained from &lt;a href=&#34;https://pixabay.com&#34;&gt;Pixabay&lt;/a&gt; via &lt;a href=&#34;https://pixabay.com/api/docs/&#34;&gt;its API&lt;/a&gt;, as shown in the GIF animation below. The source code used in the blog posts is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenRecord.gif&#34; alt=&#34;SwinjectMVVMExample ScreenRecord&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;requirements:11d7c6379da90efdd5e0a41c688871dd&#34;&gt;Requirements&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Swift 2.0&lt;/li&gt;
&lt;li&gt;Xcode 7 beta 6&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt; 0.8 or later&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://pixabay.com/api/docs/&#34;&gt;Pixabay&lt;/a&gt; API username and key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are going to use Swift 2.0 with Xcode 7 though they are still in beta versions. To use with Swift 2, a development version of ReactiveCocoa in &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/tree/swift2&#34;&gt;swift2 branch&lt;/a&gt; will be used. Notice that ReactiveCocoa 3.0 has functional style APIs like &lt;code&gt;|&amp;gt; map&lt;/code&gt; or &lt;code&gt;|&amp;gt; flatMap&lt;/code&gt;, but APIs in swift2 branch are in protocol oriented and fluent style like &lt;code&gt;.map()&lt;/code&gt; or &lt;code&gt;.flatMap()&lt;/code&gt;. Since swift2 branch is still in development, the APIs might be changed in the future.&lt;/p&gt;

&lt;p&gt;Carthage can be installed by &lt;a href=&#34;https://github.com/Carthage/Carthage/releases&#34;&gt;its installer (Carthage.pkg)&lt;/a&gt;, or &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; with the following commands.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew update
brew install carthage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can get a free API username and key at &lt;a href=&#34;https://pixabay.com/&#34;&gt;Pixabay&lt;/a&gt;. First, sign up and log in there. Then, access its &lt;a href=&#34;https://pixabay.com/api/docs/&#34;&gt;API documentation page&lt;/a&gt;. Your API username and key will be displayed in &amp;ldquo;Request parameters&amp;rdquo; section.&lt;/p&gt;

&lt;h2 id=&#34;project-setup-overview:11d7c6379da90efdd5e0a41c688871dd&#34;&gt;Project Setup Overview&lt;/h2&gt;

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-1-introduction/&#34;&gt;the last blog post&lt;/a&gt;, we learned View depended on ViewModel and ViewModel on Model in MVVM architecture. How can we force the direction of dependencies when we write protocols, classes or structs representing Models, Views or ViewModels? It is easy to get chaotic if all the types are placed in a directory, or even in an application target.&lt;/p&gt;

&lt;p&gt;Java or .NET applications are often composed of several &lt;a href=&#34;https://en.wikipedia.org/wiki/JAR_%28file_format%29&#34;&gt;JAR&lt;/a&gt;s or &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic-link_library&#34;&gt;DLL&lt;/a&gt;s to make the responsibilities of the components explicit. Since iOS 8 has introduced dynamic frameworks, it is easy to setup an iOS app composed of several dynamic frameworks. The architecture of an iOS app containing Model, View and ViewModel frameworks, as diagrammed in the image below, ensures that the direction of the dependencies is from View to ViewModel and ViewModel to Model with the dependencies injected by the application. For example, if you make a type in ViewModel framework, it can reference types in Model framework but cannot those in View framework.&lt;/p&gt;

&lt;p&gt;The architecture keeps the consistency of the direction of the dependencies, and makes the app easy to develop, test and maintain.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/Diagram-MVVMAppStructure.png&#34; alt=&#34;App Structure Diagram&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;project-setup-composing-mvvm-frameworks:11d7c6379da90efdd5e0a41c688871dd&#34;&gt;Project Setup Composing MVVM Frameworks&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start creating our Xcode project composing the MVVM frameworks. Select &lt;code&gt;File &amp;gt; New &amp;gt; Project...&lt;/code&gt; menu and &lt;code&gt;iOS &amp;gt; Application &amp;gt; Single View Application&lt;/code&gt; item. Set  its product name to &lt;code&gt;SwinjectMVVMExample&lt;/code&gt;, add &lt;code&gt;.SwinjectMVVMExample&lt;/code&gt; to the end of the bundle identifier, set language to Swift and devices to iPhone, and check &lt;code&gt;Include Unit Tests&lt;/code&gt; only&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11d7c6379da90efdd5e0a41c688871dd:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11d7c6379da90efdd5e0a41c688871dd:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Save it anywhere in your local storage.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotNewProject.png&#34; alt=&#34;Screenshot New Project&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next we are going to add Model, View and ViewModel frameworks. They will be named &lt;code&gt;ExampleModel&lt;/code&gt;, &lt;code&gt;ExampleView&lt;/code&gt; and &lt;code&gt;ExampleViewModel&lt;/code&gt;, respectively, in our example app. When you create your own app, it is recommended to name the frameworks as &lt;code&gt;YourAppName&lt;/code&gt; + &lt;code&gt;Model&lt;/code&gt;, &lt;code&gt;View&lt;/code&gt;, and &lt;code&gt;ViewModel&lt;/code&gt;. For exampe, if your app name is &lt;code&gt;Foobook&lt;/code&gt;, your framework names may be &lt;code&gt;FoobookModel&lt;/code&gt;, &lt;code&gt;FoobookView&lt;/code&gt; and &lt;code&gt;FoobookViewModel&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Select &lt;code&gt;File &amp;gt; New &amp;gt; Target...&lt;/code&gt; menu and &lt;code&gt;iOS &amp;gt; Framework &amp;amp; Library &amp;gt; Cocoa Touch Framework&lt;/code&gt;. Click &lt;code&gt;Next&lt;/code&gt; button. In the next page, set product name to &lt;code&gt;ExampleModel&lt;/code&gt;, language to Swift. Keep &lt;code&gt;Include Unit Test&lt;/code&gt; checked and click &lt;code&gt;Finish&lt;/code&gt;. In the same way, add &lt;code&gt;ExampleViewModel&lt;/code&gt; and &lt;code&gt;ExampleView&lt;/code&gt; framework targets.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotNewTarget.png&#34; alt=&#34;Screenshot New Target&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Right click on &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator (the left pane in Xcode), and select &lt;code&gt;New Group&lt;/code&gt;. Set the group name to &lt;code&gt;Tests&lt;/code&gt;. Drag &lt;code&gt;ExampleModel&lt;/code&gt;, &lt;code&gt;ExampleViewModel&lt;/code&gt;, &lt;code&gt;ExampleView&lt;/code&gt;, &lt;code&gt;ExampleModelTests&lt;/code&gt;, &lt;code&gt;ExampleViewModelTests&lt;/code&gt;, &lt;code&gt;ExampleViewTests&lt;/code&gt; and &lt;code&gt;SwinjectMVVMExampleTests&lt;/code&gt; in Project Navigator, and place them as shown in the image below. Select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator, and order the targets by dragging as shown in the image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotProjectHierarchy.png&#34; alt=&#34;Screenshot Project Hierarchy&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We are going to configure dependency and link settings of the targets. Select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator, and select &lt;code&gt;ExampleViewModel&lt;/code&gt; in Targets area. In Build Phases tab, click &lt;code&gt;+&lt;/code&gt; button in Target Dependencies section, and add &lt;code&gt;ExampleModel&lt;/code&gt;. Click &lt;code&gt;+&lt;/code&gt; button in Link Binary with Libraries section, and add &lt;code&gt;ExampleModel.framework&lt;/code&gt;. In the same way, add &lt;code&gt;ExampleViewModel&lt;/code&gt; and &lt;code&gt;ExampleViewModel.framework&lt;/code&gt; to those of &lt;code&gt;ExampleView&lt;/code&gt; target. Target settings of &lt;code&gt;ExampleModel&lt;/code&gt; and &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; can be left because &lt;code&gt;ExampleModel&lt;/code&gt; has no dependencies and &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; has those settings by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsExampleModel.png&#34; alt=&#34;Screenshot Target Settings ExampleModel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsExampleViewModel.png&#34; alt=&#34;Screenshot Target Settings ExampleViewModel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsExampleView.png&#34; alt=&#34;Screenshot Target Settings ExampleView&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsSwinjectMVVMExample.png&#34; alt=&#34;Screenshot Target Settings SwinjectMVVMExample&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We are going to configure unit test targets too. Select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator, and select &lt;code&gt;ExampleModelTests&lt;/code&gt; in Targets area. In General tab, set Host Application to &lt;code&gt;None&lt;/code&gt;. In the same way, set Host Application of &lt;code&gt;ExampleViewModelTests&lt;/code&gt; and &lt;code&gt;ExampleViewTests&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Again select &lt;code&gt;ExampleModelTests&lt;/code&gt; in Targets area. In Build Phases tab, remove &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Target Dependencies section by selecting it and click &lt;code&gt;-&lt;/code&gt; button. In the same remove target dependency on &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; from &lt;code&gt;ExampleViewModelTests&lt;/code&gt; and &lt;code&gt;ExampleViewTests&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Select &lt;code&gt;ExampleViewModelTests&lt;/code&gt; in Targets area. In Build Phases tab, add &lt;code&gt;ExampleModel.framework&lt;/code&gt; to Link Binary with Libraries section. In the same way, add &lt;code&gt;ExampleViewModel.framework&lt;/code&gt; to that of &lt;code&gt;ExampleViewTests&lt;/code&gt;. We need those links to stub or mock types in the linked frameworks.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsExampleModelTests.png&#34; alt=&#34;Screenshot Target Settings ExampleModelTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsExampleViewModelTests.png&#34; alt=&#34;Screenshot Target Settings ExampleViewModelTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsExampleViewTests.png&#34; alt=&#34;Screenshot Target Settings ExampleViewTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTargetSettingsSwinjectMVVMExampleTests.png&#34; alt=&#34;Screenshot Target Settings SwinjectMVVMExampleTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We are going to setup a build scheme. Click scheme button on the Xcode toolbar, and select &lt;code&gt;Manage Schemes...&lt;/code&gt; If you see &lt;code&gt;ExampleModel&lt;/code&gt;, &lt;code&gt;ExampleViewModel&lt;/code&gt; and &lt;code&gt;ExampleView&lt;/code&gt; schemes, select them and click &lt;code&gt;-&lt;/code&gt; button to delete them. Then select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; scheme and click &lt;code&gt;Edit&lt;/code&gt; button. Make sure that &lt;code&gt;ExampleModelTests&lt;/code&gt;, &lt;code&gt;ExampleViewModelTests&lt;/code&gt;, &lt;code&gt;ExampleViewTests&lt;/code&gt; and &lt;code&gt;SwinjectMVVMExampleTests&lt;/code&gt; are checked in Build and Test settings.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotBuildScheme.png&#34; alt=&#34;Screenshot Build Scheme&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotTestScheme.png&#34; alt=&#34;Screenshot Test Scheme&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Okay, we have finished setting up the project. Run the app (&lt;code&gt;Command-R&lt;/code&gt;), then  unit tests (&lt;code&gt;Command-U&lt;/code&gt;) to check whether the project is configured correctly. If you see an error for an umbrella header, set the target membership of the header file to the target with &lt;code&gt;Public&lt;/code&gt; accessibility as shown in the image below. Xcode sometimes creates umbrella headers with wrong target memberships.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotUmbrellaHeader.png&#34; alt=&#34;Screenshot Umbrella Header&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;installation-of-external-frameworks-with-carthage:11d7c6379da90efdd5e0a41c688871dd&#34;&gt;Installation of External Frameworks with Carthage&lt;/h2&gt;

&lt;p&gt;We are going to install &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt;, &lt;a href=&#34;https://github.com/ikesyo/Himotoki&#34;&gt;Himotoki&lt;/a&gt;, &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire&lt;/a&gt;, &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt; and &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt;. We used Alamofire, Quick and Nimble in &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the previous example project&lt;/a&gt;. This time, we are going to use Himotoki, which is a type-safe JSON decoding library, in place of &lt;a href=&#34;https://github.com/SwiftyJSON/SwiftyJSON&#34;&gt;SwiftyJSON&lt;/a&gt;. The details of Himotoki will be mentioned in the next blog post when we use it.&lt;/p&gt;

&lt;p&gt;To install them with &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;, add a text file named &lt;code&gt;Cartfile&lt;/code&gt; with the following contents. Notice that specific commit versions of some frameworks are specified because they are still in development to support Swift 2 and Xcode 7 (beta).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cartfile&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github &amp;quot;ReactiveCocoa/ReactiveCocoa&amp;quot; &amp;quot;be3d9f5a2ba0fd902c13373e320a4b86f214c1d3&amp;quot;
github &amp;quot;ikesyo/Himotoki&amp;quot; &amp;quot;a40a9df31ffa2e81daf872e9637170e3708e5478&amp;quot;
github &amp;quot;Alamofire/Alamofire&amp;quot; ~&amp;gt; 2.0.0
github &amp;quot;Swinject/Swinject&amp;quot; ~&amp;gt; 0.2.1

github &amp;quot;Quick/Quick&amp;quot; &amp;quot;1fbcd8a05f6e896e2db66a2e82527b7f24766ef8&amp;quot;
github &amp;quot;Quick/Nimble&amp;quot; &amp;quot;e3e3978ef610927d70eafd333e162855ad7b6f77&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run &lt;code&gt;carthage update --no-use-binaries&lt;/code&gt; in Terminal&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11d7c6379da90efdd5e0a41c688871dd:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11d7c6379da90efdd5e0a41c688871dd:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. Wait for a couple of minutes (or more) until Carthage finishes building the frameworks&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11d7c6379da90efdd5e0a41c688871dd:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11d7c6379da90efdd5e0a41c688871dd:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;. If you use &lt;a href=&#34;https://git-scm.com&#34;&gt;Git&lt;/a&gt;, &lt;a href=&#34;https://github.com/github/gitignore/blob/master/Swift.gitignore&#34;&gt;here is a &lt;code&gt;.gitignore&lt;/code&gt; for Swift&lt;/a&gt; excluding frameworks built by Carthage.&lt;/p&gt;

&lt;p&gt;After the build completes, right click on &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator, and select &lt;code&gt;New Group&lt;/code&gt;. Name the group &lt;code&gt;Frameworks&lt;/code&gt;. Drag and drop the frameworks built in &lt;code&gt;Carthage/Build/iOS&lt;/code&gt; directory in Finder to the group in Xcode. When you drop them, an action sheet asks you wether they should be added to targets. Uncheck all targets and click &lt;code&gt;Finish&lt;/code&gt; button.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotUmbrellaHeaderFrameworksGroup.png&#34; alt=&#34;Screenshot Umbrella Header&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator, and select &lt;code&gt;ExampleModel&lt;/code&gt; in Target section with Build Phases tab open. Drag &lt;code&gt;Alamofire.framework&lt;/code&gt;, &lt;code&gt;Himotoki.framework&lt;/code&gt;, &lt;code&gt;ReactiveCocoa.framework&lt;/code&gt; and &lt;code&gt;Result.framework&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:11d7c6379da90efdd5e0a41c688871dd:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:11d7c6379da90efdd5e0a41c688871dd:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; in the &lt;code&gt;Frameworks&lt;/code&gt; group to Link Binary with Libraries section in Build Phases tab. In the same way, add &lt;code&gt;ReactiveCocoa.framework&lt;/code&gt; and &lt;code&gt;Result.framework&lt;/code&gt; to those of &lt;code&gt;ExampleViewModel&lt;/code&gt; and &lt;code&gt;ExampleView&lt;/code&gt;. Add &lt;code&gt;Swinject.framework&lt;/code&gt; to that of &lt;code&gt;SwinjectMVVMExample&lt;/code&gt;. Add &lt;code&gt;ReactiveCocoa.framework&lt;/code&gt;, &lt;code&gt;Result.framework&lt;/code&gt;, &lt;code&gt;Quick.framework&lt;/code&gt; and &lt;code&gt;Nimble.framework&lt;/code&gt; to those of &lt;code&gt;ExampleModelTests&lt;/code&gt;, &lt;code&gt;ExampleViewModelTests&lt;/code&gt; and &lt;code&gt;ExampleViewTests&lt;/code&gt;. Add &lt;code&gt;Swinject.framework&lt;/code&gt;, &lt;code&gt;Quick.framework&lt;/code&gt; and &lt;code&gt;Nimble.framework&lt;/code&gt; to that of &lt;code&gt;SwinjectMVVMExampleTests&lt;/code&gt;. Alamofire and Himotoki are used only in our Model, Swinject only in our application and its test, and Quick and Nimble only in unit tests.&lt;/p&gt;

&lt;p&gt;Select &lt;code&gt;ExampleModelTests&lt;/code&gt; in Target section, click &lt;code&gt;+&lt;/code&gt; button under Build Phases tab, select &lt;code&gt;New Copy Files Phase&lt;/code&gt;, and name the new phase &lt;code&gt;Copy Frameworks&lt;/code&gt;. Within the phase, set Destination to &lt;code&gt;Frameworks&lt;/code&gt;. Drag &lt;code&gt;Alamofire.framework&lt;/code&gt;, &lt;code&gt;Himotoki.framework&lt;/code&gt;, &lt;code&gt;ReactiveCocoa.framework&lt;/code&gt;, &lt;code&gt;Result.framework&lt;/code&gt;, &lt;code&gt;Quick.framework&lt;/code&gt; and &lt;code&gt;Nimble.framework&lt;/code&gt; in &lt;code&gt;Frameworks&lt;/code&gt; group on Project Navigator to &lt;code&gt;Copy Frameworks&lt;/code&gt; phase. In the same way, add &lt;code&gt;Copy Frameworks&lt;/code&gt; phases to &lt;code&gt;ExampleViewModelTests&lt;/code&gt; and &lt;code&gt;ExampleViewTests&lt;/code&gt;, and drag the 6 frameworks to the phases. Add &lt;code&gt;Copy Frameworks&lt;/code&gt; phase to &lt;code&gt;SwinjectMVVMExampleTests&lt;/code&gt; in the same way, and add &lt;code&gt;Quick.framework&lt;/code&gt; and &lt;code&gt;Nimble.framework&lt;/code&gt; to the phase. Because &lt;code&gt;SwinjectMVVMExampleTests&lt;/code&gt; is hosted in the app, only Quick and Nimble, which are not used in the app, are added to the phase.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsExampleModel.png&#34; alt=&#34;Screenshot Link Settings ExampleModel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsExampleViewModel.png&#34; alt=&#34;Screenshot Link Settings ExampleViewModel&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsExampleView.png&#34; alt=&#34;Screenshot Link Settings ExampleView&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsSwinjectMVVMExample.png&#34; alt=&#34;Screenshot Link Settings SwinjectMVVMExample&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsExampleModelTests.png&#34; alt=&#34;Screenshot Link Settings ExampleModelTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsExampleViewModelTests.png&#34; alt=&#34;Screenshot Link Settings ExampleViewModelTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsExampleViewTests.png&#34; alt=&#34;Screenshot Link Settings ExampleViewTests&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotLinkSettingsSwinjectMVVMExampleTests.png&#34; alt=&#34;Screenshot Link Settings SwinjectMVVMExample&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The last settings are as specified in &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;the README of Carthage&lt;/a&gt;. Select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator, and select &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Targets section with Build Phases tab open. Click &lt;code&gt;+&lt;/code&gt; button under the tab, and select &lt;code&gt;New Run Script Phase&lt;/code&gt;. Rename the phase to &lt;code&gt;Run Script for Frameworks by Carthage&lt;/code&gt; and add the following line to the script text field.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/bin/carthage copy-frameworks
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then add the following paths to Input Files section by clicking &lt;code&gt;+&lt;/code&gt; button.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(SRCROOT)/Carthage/Build/iOS/Alamofire.framework
$(SRCROOT)/Carthage/Build/iOS/Himotoki.framework
$(SRCROOT)/Carthage/Build/iOS/ReactiveCocoa.framework
$(SRCROOT)/Carthage/Build/iOS/Result.framework
$(SRCROOT)/Carthage/Build/iOS/Swinject.framework
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again click the &lt;code&gt;+&lt;/code&gt; button under Build Phases tab, select &lt;code&gt;New Copy Files Phase&lt;/code&gt; and name the phase &lt;code&gt;Copy dSYMs&lt;/code&gt;. Set its destination to &lt;code&gt;Products Directory&lt;/code&gt;, and drag &lt;code&gt;Alamofire.framework.dSYM&lt;/code&gt;, &lt;code&gt;Himotoki.framework.dSYM&lt;/code&gt;, &lt;code&gt;ReactiveCocoa.framework.dSYM&lt;/code&gt;, &lt;code&gt;Result.framework.dSYM&lt;/code&gt; and &lt;code&gt;Swinject.framework.dSYM&lt;/code&gt; from &lt;code&gt;Carthage/Build/iOS/&lt;/code&gt; directory in Finder to the &lt;code&gt;Copy dSYMs&lt;/code&gt; phase in Xcode. Right click on &lt;code&gt;SwinjectMVVMExample&lt;/code&gt; in Project Navigator and select &lt;code&gt;New Group&lt;/code&gt;. Name the new group &lt;code&gt;dSYMs&lt;/code&gt; and put the dSYM files that were added to Project Navigator automatically into the group to tidy up.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotCarthageScriptAnddSYMs.png&#34; alt=&#34;Screenshot dSYMs Group&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenshotdSYMsGroup.png&#34; alt=&#34;Screenshot dSYMs Group&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Configurations! You got the project set up. Try running the app and unit tests by &lt;code&gt;Command-R&lt;/code&gt; and &lt;code&gt;Command-U&lt;/code&gt; to confirm the project is setup as intended. If you get an error, download &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;the project on GitHub&lt;/a&gt; and compare your project with it to investigate what is wrong.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:11d7c6379da90efdd5e0a41c688871dd&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We found that the architecture of the app composed of Model, View and ViewModel frameworks ensured the direction of dependencies was consistent from View to ViewModel and ViewModel to Model. We setup the Xcode project in the MVVM architecture, and installed some external frameworks with Carthage. In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-3-designing-the-model/&#34;&gt;the next blog post&lt;/a&gt;, we will start developing the app with ReactiveCocoa and Swinject to take advantage of the MVVM architecture.&lt;/p&gt;

&lt;p&gt;If you have questions, suggestions or problems, feel free to leave comments.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:11d7c6379da90efdd5e0a41c688871dd:1&#34;&gt;UI tests are excluded because still Xcode 7 is beta. This blog post will be updated to include them after Xcode 7 is officially released.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11d7c6379da90efdd5e0a41c688871dd:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11d7c6379da90efdd5e0a41c688871dd:2&#34;&gt;&lt;code&gt;--no-use-binaries&lt;/code&gt; option is supplied to &lt;code&gt;carthage update&lt;/code&gt; command to avoid downloading zipped frameworks built with an older beta version of Xcode. If you install official release versions of the frameworks for an official release version of Xcode, you can just run &lt;code&gt;carthage update&lt;/code&gt;.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11d7c6379da90efdd5e0a41c688871dd:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11d7c6379da90efdd5e0a41c688871dd:3&#34;&gt;If you get an error on &lt;code&gt;carthage update --no-use-binaries&lt;/code&gt; command, run it again with &lt;code&gt;--verbose&lt;/code&gt; option too to investigate the problem.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11d7c6379da90efdd5e0a41c688871dd:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:11d7c6379da90efdd5e0a41c688871dd:4&#34;&gt;&lt;code&gt;Result.framework&lt;/code&gt; is used by ReactiveCocoa.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:11d7c6379da90efdd5e0a41c688871dd:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection in MVVM Architecture with ReactiveCocoa Part 1: Introduction</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-1-introduction/</link>
      <pubDate>Thu, 27 Aug 2015 13:45:30 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-1-introduction/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/&#34;&gt;the last blog post&lt;/a&gt;, we developed an app demonstrating dependency injection with &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt; in a simple architecture. In the series of blog posts from today, we are going to develop an app taking advantage of dependency injection in &lt;a href=&#34;https://en.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVM (Model-View-ViewModel)&lt;/a&gt; architecture with &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCococa&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Through the series of the blog posts, you will learn:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;How to setup an Xcode project to explicitly represent MVVM architecture.&lt;/li&gt;
&lt;li&gt;How to inject dependencies in the architecture with Swinject.&lt;/li&gt;
&lt;li&gt;How to use ReactiveCocoa to propagate events from Model to ViewModel and ViewModel to View.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The blog posts concentrate on the practical development using dependency injection, Swinject, MVVM and ReactiveCocoa. Please refer to other articles to learn the details of them. Recommended articles will be referenced later in the blog posts.&lt;/p&gt;

&lt;p&gt;The example app we are going to develop asynchronously searches, downloads and displays images obtained from &lt;a href=&#34;https://pixabay.com&#34;&gt;Pixabay&lt;/a&gt; via &lt;a href=&#34;https://pixabay.com/api/docs/&#34;&gt;its API&lt;/a&gt;, as shown in the GIF animation below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectMVVMExampleScreenRecord.gif&#34; alt=&#34;SwinjectMVVMExample ScreenRecord&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The source code used in the blog posts is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectMVVMExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;mvvm:90b51da2b75144dcb148da08a7b03a1a&#34;&gt;MVVM&lt;/h2&gt;

&lt;p&gt;MVVM (Model-View-ViewModel) is an architecture or pattern to make dependencies of components simple as View depends on ViewModel and ViewModel depends on Model linearly. Its event flow is linearly, in reverse, from Model to ViewModel and ViewModel to View.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/Diagram-MVVM.png&#34; alt=&#34;MVVM Diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On the other hand, in MVC (Model-View-Controler) architecture or pattern, Controller depends on Model and View, and its event flow is from Model to Controller and View to Controller.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/Diagram-MVC.png&#34; alt=&#34;MVC Diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The problem of MVC is that Controller tends to get large and complex as a project evolves because it has to take care of both Model and View, which mean everything. Actually MVC is a good pattern in web applications with the support of frameworks such as &lt;a href=&#34;http://rubyonrails.org&#34;&gt;Ruby on Rails&lt;/a&gt; or &lt;a href=&#34;http://www.asp.net/mvc&#34;&gt;ASP.NET MVC&lt;/a&gt;, but in iOS apps MVC often makes monolithic and hard-to-maintain code.&lt;/p&gt;

&lt;p&gt;For the disadvantage of MVC, MVVM is getting popular to develop mobile apps or desktop apps. In iOS apps, the &amp;ldquo;View&amp;rdquo; of MVVM is composed of &amp;ldquo;View&amp;rdquo; (UIView) and &amp;ldquo;ViewController&amp;rdquo; (UIViewController). View logic, e.g. a value &lt;code&gt;1000&lt;/code&gt; should be displayed as &lt;code&gt;&amp;quot;1,000&amp;quot;&lt;/code&gt;, is implemented in ViewModel. View simply uses values provided by ViewModel to display. Model is responsible for business logic. Because of the separation of the responsibilities, an iOS app in MVVM architecture is easier to test.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/Diagram-MVVM-iOS.png&#34; alt=&#34;iOS MVVM Diagram&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;references:90b51da2b75144dcb148da08a7b03a1a&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.objc.io/issues/13-architecture/mvvm/&#34;&gt;Introduction to MVVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sprynthesis.com/2014/12/06/reactivecocoa-mvvm-introduction/&#34;&gt;ReactiveCocoa and MVVM, an Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1&#34;&gt;MVVM Tutorial with ReactiveCocoa: Part &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reactivecocoa:90b51da2b75144dcb148da08a7b03a1a&#34;&gt;ReactiveCocoa&lt;/h2&gt;

&lt;p&gt;MVVM propagates events from Model to ViewModel and ViewModel to View. We are going to use ReactiveCocoa to handle the events. The framework provides APIs to compose and transform event streams. Without ReactiveCocoa, events are represented by delegate methods, callback closures, UIControl actions, or KVO (Key-Value Observation). We had to write a different way of handling to each type of events. With ReactiveCocoa, an event is represented by &lt;code&gt;Event&lt;/code&gt; and event streams are represented by &lt;code&gt;Signal&lt;/code&gt; or &lt;code&gt;SignalProducer&lt;/code&gt;. We can handle the events in the same abstracted way regardless of the original source of events. From the next blog post, we will take advantage of the simplicity of the events with ReactiveCocoa. If you are new to ReactiveCocoa, it is recommended to read the following articles before proceeding to the next post.&lt;/p&gt;

&lt;h3 id=&#34;references-1:90b51da2b75144dcb148da08a7b03a1a&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCocoa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/Documentation/FrameworkOverview.md&#34;&gt;Framework Overview&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.scottlogic.com/2015/04/24/first-look-reactive-cocoa-3.html&#34;&gt;A First Look at ReactiveCocoa 3.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion:90b51da2b75144dcb148da08a7b03a1a&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;MVVM has the simple and linear dependencies of View on ViewModel and ViewModel on Model, and event flows from Model to ViewModel and ViewModel to View. ReactiveCocoa turns various kind of events, such as delegate methods or callback closures, into a single type &lt;code&gt;Event&lt;/code&gt; of events. For the simplicity, an iOS app in MVVM architecture with ReactiveCocoa is easier to maintain and test. From &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-in-mvvm-architecture-with-reactivecocoa-part-2-project-setup/&#34;&gt;the next blog post&lt;/a&gt;, step-by-step development with MVVM, ReactiveCocoa, dependency injection and Swinject will be demonstrated.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection Framework for Swift - Simple Weather App Example with Swinject Part 2/2</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/</link>
      <pubDate>Fri, 14 Aug 2015 17:14:24 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the last blog post&lt;/a&gt;, we developed the model part of the simple weather app, and learnt how to remove tightly coupled dependencies by using dependency injection and &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;. We found the decoupling made unit testing easier. In this blog post, we are going to develop the UI part of the app, and will learn how to wire up the decoupled components with Swinject.&lt;/p&gt;

&lt;p&gt;The source code used in this blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectSimpleExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;basic-ui-structure:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Basic UI Structure&lt;/h2&gt;

&lt;p&gt;First, we are going to make a basic UI structure to show the weather information in a table view. The UI components will be instantiated from a storyboard, but instantiation of the storyboard itself will be written by hand to use &lt;code&gt;SwinjectStoryboard&lt;/code&gt; inheriting &lt;code&gt;UIStoryboard&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Open &lt;code&gt;Info.plist&lt;/code&gt; and remove &lt;code&gt;&amp;quot;Main storyboard file base name&amp;quot;&lt;/code&gt; key, which might be displayed as &lt;code&gt;&amp;quot;UIMainStoryboardFile&amp;quot;&lt;/code&gt; if you are showing raw keys.&lt;/p&gt;

&lt;p&gt;Remove &lt;code&gt;ViewController.swift&lt;/code&gt; and add &lt;code&gt;WeatherTableViewController.swift&lt;/code&gt;, which has an empty definition of &lt;code&gt;WeatherTableViewController&lt;/code&gt;. We will implement the class later with the dependency injection pattern.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit

class WeatherTableViewController: UITableViewController {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open &lt;code&gt;Main.storyboard&lt;/code&gt; and remove the existing view controller. Then add a new navigation controller to the storyboard from the object library pane.&lt;/p&gt;

&lt;p&gt;Select the navigation controller and check &lt;code&gt;&amp;quot;Is Initial View Controller&amp;quot;&lt;/code&gt; in the attribute inspector.&lt;/p&gt;

&lt;p&gt;Select the table view controller, which is the root view controller of the navigation controller, and set its custom class to &lt;code&gt;WeatherTableViewController&lt;/code&gt;. Select the prototype cell on the table view, and set its style to &lt;code&gt;Right Detail&lt;/code&gt; and identifier to &lt;code&gt;&amp;quot;Cell&amp;quot;&lt;/code&gt;. Select the navigation item on the table view controller, and set its title to &lt;code&gt;&amp;quot;Weather Now&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleStoryboardScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Storyboard Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Modify &lt;code&gt;AppDelegate.swift&lt;/code&gt; to instantiate the initial view controller from the storyboard by hand. Here, we use &lt;code&gt;SwinjectStoryboard&lt;/code&gt; instead of &lt;code&gt;UIStoryboard&lt;/code&gt; to add dependency injection later. The instantiation of &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is not performed with an initializer but &lt;code&gt;create&lt;/code&gt;  function&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import Swinject

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(
        application: UIApplication,
        didFinishLaunchingWithOptions
        launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
    {
        let window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window.backgroundColor = UIColor.whiteColor()
        window.makeKeyAndVisible()
        self.window = window

        let storyboard = SwinjectStoryboard.create(name: &amp;quot;Main&amp;quot;, bundle: nil)
        window.rootViewController = storyboard.instantiateInitialViewController()

        return true
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to run the app. Type &lt;code&gt;Command-R&lt;/code&gt; to run. You will see an empty table view like the following image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleEmptyScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Empty Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dependency-injection-to-view-controller:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Dependency Injection to View Controller&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement the empty table view controller and add dependency injection to it.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;weatherFetcher&lt;/code&gt; property to &lt;code&gt;WeatherTableViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class WeatherTableViewController: UITableViewController {
    var weatherFetcher: WeatherFetcher?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify &lt;code&gt;AppDelegate&lt;/code&gt; to instantiate &lt;code&gt;SwinjectStoryboard&lt;/code&gt; with a configured &lt;code&gt;Container&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(
        application: UIApplication,
        didFinishLaunchingWithOptions
        launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
    {
        let window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window.backgroundColor = UIColor.whiteColor()
        window.makeKeyAndVisible()
        self.window = window

        let container = createContainer()
        let storyboard = SwinjectStoryboard.create(
            name: &amp;quot;Main&amp;quot;,
            bundle: nil,
            container: container)
        window.rootViewController = storyboard.instantiateInitialViewController()

        return true
    }

    private func createContainer() -&amp;gt; Container {
        let container = Container()
        container.registerForStoryboard(WeatherTableViewController.self) { r, c in
            c.weatherFetcher = r.resolve(WeatherFetcher.self)
        }
        container.register(Networking.self) { _ in Network() }
        container.register(WeatherFetcher.self) { r in
            WeatherFetcher(networking: r.resolve(Networking.self)!)
        }
        return container
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;createContainer&lt;/code&gt; method, first, a &lt;code&gt;Container&lt;/code&gt; instance is created, then configured. &lt;code&gt;registerForStoryboard&lt;/code&gt; is used to configure dependencies of a view controller. Here &lt;code&gt;WeatherTableViewController&lt;/code&gt; is configured to get &lt;code&gt;weatherFetcher&lt;/code&gt; property set to a resolved instance of &lt;code&gt;WeatherFetcher&lt;/code&gt;. This is called &amp;ldquo;property injection&amp;rdquo;. &lt;code&gt;Networking&lt;/code&gt; protocol, which was defined in &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the last blog post&lt;/a&gt;, is configured to be &lt;code&gt;Network&lt;/code&gt; encapsulating Alamofire. &lt;code&gt;WeatherFetcher&lt;/code&gt; is configured to be initialized with a resolved &lt;code&gt;Networking&lt;/code&gt; instance. This is called &amp;ldquo;initializer injection&amp;rdquo;. At the end, the method returns the configured &lt;code&gt;container&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; method, the configured &lt;code&gt;container&lt;/code&gt; is passed to &lt;code&gt;SwinjectStoryboard&lt;/code&gt;. That&amp;rsquo;s all. Simple, isn&amp;rsquo;t it? Just configured and passed it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s move on to the implementation of &lt;code&gt;WeatherTableViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class WeatherTableViewController: UITableViewController {
    var weatherFetcher: WeatherFetcher?

    private var cities = [City]() {
        didSet {
            tableView.reloadData()
        }
    }

    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)

        weatherFetcher?.fetch {
            if let cities = $0 {
                self.cities = cities
            }
            else {
                // Show an error message.
            }
        }
    }

    // MARK: UITableViewDataSource
    override func tableView(
        tableView: UITableView,
        numberOfRowsInSection section: Int) -&amp;gt; Int
    {
        return cities.count
    }

    override func tableView(
        tableView: UITableView,
        cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell
    {
        let cell = tableView.dequeueReusableCellWithIdentifier(
            &amp;quot;Cell&amp;quot;, forIndexPath: indexPath)
        let city = cities[indexPath.row]
        cell.textLabel?.text = city.name
        cell.detailTextLabel?.text = city.weather
        return cell
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, &lt;code&gt;cities&lt;/code&gt; property is added with an initial empty array of &lt;code&gt;City&lt;/code&gt;. Setting the property triggers refreshing the table view.&lt;/p&gt;

&lt;p&gt;Second, &lt;code&gt;viewWillAppear&lt;/code&gt; is overridden to start fetching weather information by &lt;code&gt;fetch&lt;/code&gt; method&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. It takes a closure, and invokes the closure with an array of &lt;code&gt;City&lt;/code&gt; when the weather data are retrieved. In the closure, &lt;code&gt;self.cities&lt;/code&gt; is set and the table view is refreshed consequently. If &lt;code&gt;fetch&lt;/code&gt; fails, it passes &lt;code&gt;nil&lt;/code&gt; to the closure. In this blog post, the error handling is omitted, but the source code in &lt;a href=&#34;https://github.com/Swinject/SwinjectSimpleExample&#34;&gt;the GitHub repository&lt;/a&gt; has an implementation to show an error message.&lt;/p&gt;

&lt;p&gt;At last, &lt;code&gt;tableView:numberOfRowsInSection:&lt;/code&gt; and &lt;code&gt;tableView:cellForRowAtIndexPath:&lt;/code&gt; are implemented to tell the number of rows and to set city name and weather labels of a cell.&lt;/p&gt;

&lt;p&gt;We have finished implementing the UI. Let&amp;rsquo;s run the app. You will see the table view filled with current weather information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;testing-view-controller:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Testing View Controller&lt;/h2&gt;

&lt;p&gt;We have already seen the app works, but let me add a unit test for &lt;code&gt;WeatherTableViewController&lt;/code&gt;. We are going to check the view controller starts fetching weather data when the view appears. In this test, we will see the concept of &lt;a href=&#34;https://en.wikipedia.org/wiki/Mock_object&#34;&gt;mocking&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;WeatherTableViewControllerSpec.swift&lt;/code&gt; to &lt;code&gt;SwinjectSimpleExampleTests&lt;/code&gt; with the following content.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewControllerSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Swinject
@testable import SwinjectSimpleExample

class WeatherTableViewControllerSpec: QuickSpec {
    class MockNetwork: Networking {
        var requestCount = 0

        func request(response: NSData? -&amp;gt; ()) {
            requestCount++
        }
    }

    override func spec() {
        var container: Container!
        beforeEach {
            container = Container()
            container.register(Networking.self) { _ in MockNetwork() }
                .inObjectScope(.Container)
            container.register(WeatherFetcher.self) { r in
                WeatherFetcher(networking: r.resolve(Networking.self)!)
            }
            container.register(WeatherTableViewController.self) { r in
                let controller = WeatherTableViewController()
                controller.weatherFetcher = r.resolve(WeatherFetcher.self)
                return controller
            }
        }

        it(&amp;quot;starts fetching weather information when the view is about appearing.&amp;quot;) {
            let network = container.resolve(Networking.self) as! MockNetwork
            let controller = container.resolve(WeatherTableViewController.self)!

            expect(network.requestCount) == 0
            controller.viewWillAppear(true)
            expect(network.requestCount).toEventually(equal(1))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the beginning, a mock of &lt;code&gt;Networking&lt;/code&gt; is defined as &lt;code&gt;MockNetwork&lt;/code&gt;. It has &lt;code&gt;request&lt;/code&gt; method, but never returns a response. Instead, it increments a counter named &lt;code&gt;requestCount&lt;/code&gt;. A mock is used to check whether methods or properties of an instance are called as intended. Although it may return dummy data like a stub does, the ability to check method or property calls differentiates a mock from a stub.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;spec&lt;/code&gt;, we skip to &lt;code&gt;it&lt;/code&gt; for now. First, instances of &lt;code&gt;MockNetwork&lt;/code&gt; and &lt;code&gt;WeatherTableViewController&lt;/code&gt; are retrieved from the configured &lt;code&gt;container&lt;/code&gt;. Because we know &lt;code&gt;Networking&lt;/code&gt; is resolved to &lt;code&gt;MockNetwork&lt;/code&gt;, we cast the returned instance to &lt;code&gt;MockNetwork&lt;/code&gt;. Then, it is checked, by the &lt;code&gt;requestCount&lt;/code&gt; counter, that &lt;code&gt;request&lt;/code&gt; method of the mock is called once after &lt;code&gt;viewWillAppear&lt;/code&gt; of the view controller is called. Although &lt;code&gt;WeatherTableViewController&lt;/code&gt; does not directly own &lt;code&gt;Networking&lt;/code&gt; instance, we can ensure related instances are connected correctly by checking the call of the mocked method.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go back to the configuration of the &lt;code&gt;container&lt;/code&gt;. First, &lt;code&gt;Networking&lt;/code&gt; is registered to be resolved to &lt;code&gt;MockNetwork&lt;/code&gt;, and its instance is configured to be shared within the &lt;code&gt;container&lt;/code&gt;. By setting the object scope, it is ensured that the instance of &lt;code&gt;MockNetwork&lt;/code&gt; to check the counter is identical to the instance indirectly owned by &lt;code&gt;WeatherTableViewController&lt;/code&gt;. Second, initializer injection of &lt;code&gt;WeatherFetcher&lt;/code&gt; dependency is registered. Third, property injection of &lt;code&gt;WeatherTableViewController&lt;/code&gt; dependency is registered.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s run the unit test. Passed, right? Assume you keep developing the weather app to add more features. The unit test gives you confidence that you will never break the connection of the UI and model.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We have developed the UI part of the simple weather app, and learnt how to wire the components with a dependency injection container. &lt;code&gt;SwinjectStoryboard&lt;/code&gt; makes it easy to inject dependencies to view controllers defined in a storyboard. We have learnt, at last, a mock can be used to ensure that the components are wired as intended by checking a method call to the instance located at the terminal of the chain of dependencies.&lt;/p&gt;

&lt;p&gt;In the next blog post, we will develop a larger example app in &lt;a href=&#34;https://en.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVM&lt;/a&gt; architecture with the popular and elegant Swift &lt;a href=&#34;https://en.wikipedia.org/wiki/Reactive_programming&#34;&gt;reactive programming&lt;/a&gt; framework, &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCococa&lt;/a&gt;. Of course, we will take advantage of dependency injection with Swinject to wire up the loosely coupled MVVM components.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;The instantiation of &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is a bit tricky because &lt;code&gt;UIStoryboard&lt;/code&gt; does not have a normal designated initializer to override by its child classes. To workaround this problem, &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is instantiated with &lt;code&gt;create&lt;/code&gt; function instead of an initializer.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;In the example app, &lt;code&gt;fetch&lt;/code&gt; is called only in &lt;code&gt;viewWillAppear&lt;/code&gt;, but a product app should have a button or something else to refresh the weather information.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection Framework for Swift - Simple Weather App Example with Swinject Part 1/2</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/</link>
      <pubDate>Thu, 13 Aug 2015 09:16:58 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-introduction-to-swinject/&#34;&gt;the last blog post&lt;/a&gt;, we walked through the concept of dependency injection and basic usage of &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, the dependency injection framework for Swift. In this blog post, we are going to develop the simple weather app that you saw its screenshot in the last blog post. During the simple but essential steps of the development, you will see how to get rid of tightly coupled dependencies by using the dependency injection pattern and Swinject.&lt;/p&gt;

&lt;p&gt;The source code used in this blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectSimpleExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;requirements:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Requirements&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7 (beta)&lt;/li&gt;
&lt;li&gt;OpenWeatherMap API key&lt;/li&gt;
&lt;li&gt;CocoaPods 0.38 or later&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are going to use Xcode 7 although it is still beta. It is beta 6 at the timing of writing this blog post. Xcode 7 supports &lt;code&gt;@testable import&lt;/code&gt; to access &lt;code&gt;internal&lt;/code&gt; types, functions or properties in unit test targets.&lt;/p&gt;

&lt;p&gt;Also, we will use &lt;a href=&#34;http://openweathermap.org&#34;&gt;OpenWeatherMap&lt;/a&gt; for a free API to get weather information. &lt;a href=&#34;http://home.openweathermap.org/users/sign_up&#34;&gt;Sign up&lt;/a&gt; and get a free API key.&lt;/p&gt;

&lt;p&gt;To install Swinject and some frameworks, we will use &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;preparation-of-the-project:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Preparation of the Project&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with a new Xcode project. Select &lt;code&gt;File &amp;gt; New &amp;gt; Project...&lt;/code&gt; menu and &lt;code&gt;iOS &amp;gt; Application &amp;gt; Single View Application&lt;/code&gt; item. Set  its product name to &lt;code&gt;SwinjectSimpleExample&lt;/code&gt;, language to Swift and devices to iPhone. Check &lt;code&gt;Include Unit Tests&lt;/code&gt; only&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, then save it anywhere in your local storage.&lt;/p&gt;

&lt;p&gt;Then, we are going to install &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire&lt;/a&gt;, &lt;a href=&#34;https://github.com/SwiftyJSON/SwiftyJSON&#34;&gt;SwiftyJSON&lt;/a&gt;, &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt; and &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt; with &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. Create &lt;code&gt;Podfile&lt;/code&gt; with the following text content in the project root directory. Then run &lt;code&gt;pod install&lt;/code&gt; command to install them. Since Xcode 7 is still beta, specific commits of Alamofire and SwiftyJSON are specified&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;
platform :ios, &#39;8.0&#39;
use_frameworks!

pod &#39;Alamofire&#39;, :git =&amp;gt; &#39;https://github.com/Alamofire/Alamofire.git&#39;, :commit =&amp;gt; &#39;1b7b1f1aa&#39;
pod &#39;SwiftyJSON&#39;, :git =&amp;gt; &#39;https://github.com/SwiftyJSON/SwiftyJSON.git&#39;, :commit =&amp;gt; &#39;45ca854ce&#39;
pod &#39;Swinject&#39;, &#39;~&amp;gt; 0.2&#39;

target &#39;SwinjectSimpleExampleTests&#39; do
    pod &#39;Quick&#39;, &#39;~&amp;gt; 0.5.0&#39;
    pod &#39;Nimble&#39;, &#39;2.0.0-rc.2&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alamofire is a networking library to write request and asynchronous response simply. SwiftyJSON is a library to access JSON elements simply. Quick is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Behavior-driven_development&#34;&gt;behavior-driven development&lt;/a&gt; framework to write tests as specs in simple structures. Nimble is a matcher framework that is expressive and supports asynchronous tests. For details, please visit their project pages.&lt;/p&gt;

&lt;p&gt;To use the free weather API on iOS 9, we have to allow HTTP connections. Open &lt;code&gt;Info.plist&lt;/code&gt; and add &lt;code&gt;NSAppTransportSecurity&lt;/code&gt; dictionary with &lt;code&gt;NSAllowsArbitraryLoads&lt;/code&gt; element set to &lt;code&gt;true&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.  &lt;a href=&#34;http://stackoverflow.com/questions/30720813/cfnetwork-sslhandshake-failed-ios-9&#34;&gt;Here&lt;/a&gt; is more information about the setting and its background.&lt;/p&gt;

&lt;h2 id=&#34;without-dependency-injection:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Without Dependency Injection&lt;/h2&gt;

&lt;p&gt;First, without dependency injection, we are going to implement a model to handle weather information retrieved through the network service. We will see what can be a problem if we do not care about coupled dependencies.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;City.swift&lt;/code&gt; to &lt;code&gt;SwinjectSimpleExample&lt;/code&gt; group in the project. We define &lt;code&gt;City&lt;/code&gt; to be an entity representing a city with weather information.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;City.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct City {
    let id: Int
    let name: String
    let weather: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;OpenWeatherMap.swift&lt;/code&gt; to store configurations of OpenWeatherMap API. Here please fill &lt;code&gt;apiKey&lt;/code&gt; with your own API key.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenWeatherMap.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct OpenWeatherMap {
    private static let apiKey = &amp;quot;YOUR API KEY HERE&amp;quot;

    private static let cityIds = [
        6077243, 524901, 5368361, 1835848, 3128760, 4180439,
        2147714, 264371, 1816670, 2643743, 3451190, 1850147
    ]

    static let url = &amp;quot;http://api.openweathermap.org/data/2.5/group&amp;quot;

    static var parameters: [String: String] {
        return [
            &amp;quot;APPID&amp;quot;: apiKey,
            &amp;quot;id&amp;quot;: cityIds.map { String($0) }.joinWithSeparator(&amp;quot;,&amp;quot;)
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;WeatherFetcher.swift&lt;/code&gt; to implement &lt;code&gt;WeatherFetcher&lt;/code&gt;, which has &lt;code&gt;fetch&lt;/code&gt; function taking a callback to handle an optional array of &lt;code&gt;Cities&lt;/code&gt; returned from OpenWeatherMap.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcher.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import Alamofire
import SwiftyJSON

struct WeatherFetcher {
    static func fetch(response: [City]? -&amp;gt; ()) {
        Alamofire.request(.GET, OpenWeatherMap.url, parameters: OpenWeatherMap.parameters)
            .response { _, _, data, _ in
                let cities = data.map { decode($0) }
                response(cities)
            }
    }

    private static func decode(data: NSData) -&amp;gt; [City] {
        let json = JSON(data: data)
        var cities = [City]()
        for (_, j) in json[&amp;quot;list&amp;quot;] {
            if let id = j[&amp;quot;id&amp;quot;].int {
                let city = City(
                    id: id,
                    name: j[&amp;quot;name&amp;quot;].string ?? &amp;quot;&amp;quot;,
                    weather: j[&amp;quot;weather&amp;quot;][0][&amp;quot;main&amp;quot;].string ?? &amp;quot;&amp;quot;)
                cities.append(city)
            }
        }
        return cities
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fetch&lt;/code&gt; function uses Alamofire to send a request to the server and to get a response as JSON data asynchronously. The specifications of API call and response JSON format are described in &lt;a href=&#34;http://openweathermap.org/current#severalid&#34;&gt;&amp;ldquo;Call for several city IDs&amp;rdquo; section of OpenWeatherMap site&lt;/a&gt;.
The &lt;code&gt;data&lt;/code&gt; parameter in the closure passed to &lt;code&gt;response&lt;/code&gt; from &lt;code&gt;Alamofire&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the response has an error. We do not care about details of the error and just pass &lt;code&gt;nil&lt;/code&gt; to the callback to &lt;code&gt;fetch&lt;/code&gt; in this example although the error should be handled in a product app.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;decode&lt;/code&gt; function parses the JSON data returned from the server. It is called as &lt;code&gt;data.map { decode($0) }&lt;/code&gt; in &lt;code&gt;fetch&lt;/code&gt; where &lt;code&gt;map&lt;/code&gt; executes the trailing closure if &lt;code&gt;data&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt;, otherwise returns nil. The &lt;code&gt;decode&lt;/code&gt; function uses SwiftyJSON to map the JSON data to an array of our &lt;code&gt;City&lt;/code&gt; entities.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a unit test to &lt;code&gt;SwinjectSimpleExampleTests&lt;/code&gt; group in our project. The filename is &lt;code&gt;WeatherFetcherSpec.swift&lt;/code&gt; and its target is set to &lt;code&gt;SwinjectSimpleExampleTests&lt;/code&gt; when we create the file. The test is going to check whether the weather data can be retrieved and parsed correctly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcherSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
@testable import SwinjectSimpleExample

class WeatherFetcherSpec: QuickSpec {
    override func spec() {
        it(&amp;quot;returns cities.&amp;quot;) {
            var cities: [City]?
            WeatherFetcher.fetch { cities = $0 }

            expect(cities).toEventuallyNot(beNil())
            expect(cities?.count).toEventually(equal(12))
            expect(cities?[0].id).toEventually(equal(6077243))
            expect(cities?[0].name).toEventually(equal(&amp;quot;Montreal&amp;quot;))
            expect(cities?[0].weather).toEventually(equal(&amp;quot;Clouds&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Quick and Nimble, each test is written in an &lt;code&gt;it&lt;/code&gt; closure, and each expectation is expressed as &lt;code&gt;expect(something).to(condition)&lt;/code&gt; or &lt;code&gt;expect(something).toNot(condition)&lt;/code&gt; synchronously, or &lt;code&gt;expect(something).toEventually(condition)&lt;/code&gt; or &lt;code&gt;expect(something).toEventuallyNot(condition)&lt;/code&gt; asynchronously. &lt;code&gt;WeatherFetcher.fetch&lt;/code&gt; sets &lt;code&gt;cities&lt;/code&gt; asynchronously when weather data is retrieved, so we use the latter ones here.&lt;/p&gt;

&lt;p&gt;First, we check &lt;code&gt;cities&lt;/code&gt;, which is initialized with &lt;code&gt;nil&lt;/code&gt;, should be set to an array after &lt;code&gt;fetch&lt;/code&gt; invokes the callback asynchronously. Second, the number of &lt;code&gt;cities&lt;/code&gt; should be &lt;code&gt;12&lt;/code&gt; because our request to the API has 12 city IDs. From the third to fifth, we check only the first city for simplicity. The &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;weather&lt;/code&gt; should be &lt;code&gt;6077243&lt;/code&gt;, &lt;code&gt;&amp;quot;Montreal&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;Clouds&amp;quot;&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Okay. We are ready to run the unit test. Type &lt;code&gt;Command-U&lt;/code&gt; to run. Did you see the test passed? I think some people saw it passed, but the others not. Why? Because the weather in &amp;ldquo;Montreal&amp;rdquo; in the real world right now must be &amp;ldquo;Clouds&amp;rdquo; to pass the test. How can we write a test passing regardless of the current weather? It is actually difficult to write if the part parsing JSON data depends on the part retrieving the data from the server.&lt;/p&gt;

&lt;h2 id=&#34;with-dependency-injection:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;With Dependency Injection&lt;/h2&gt;

&lt;p&gt;In the last section, we found the tightly coupled dependency of the parser on the network, namely Alamofire, made the test difficult. In this section, we are going to decouple them, inject the dependency and write a better test.&lt;/p&gt;

&lt;p&gt;First, add &lt;code&gt;Networking.swift&lt;/code&gt; with the following protocol definition. It has &lt;code&gt;request&lt;/code&gt; method taking a callback to pass response data from the network.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Networking.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

protocol Networking {
    func request(response: NSData? -&amp;gt; ())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;Network.swift&lt;/code&gt; to implement &lt;code&gt;Network&lt;/code&gt; that conforms &lt;code&gt;Networking&lt;/code&gt; protocol. It encapsulates Alamofire.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Network.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import Alamofire

struct Network : Networking {
    func request(response: NSData? -&amp;gt; ()) {
        Alamofire.request(.GET, OpenWeatherMap.url, parameters: OpenWeatherMap.parameters)
            .response { _, _, data, _ in
                response(data)
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify &lt;code&gt;WeatherFetcher&lt;/code&gt; to get &lt;code&gt;Networking&lt;/code&gt; injected when it is instantiated and to use it to request weather data to the server. Note that &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; functions were &lt;code&gt;static&lt;/code&gt; in the last section, but here they are instance methods to use the &lt;code&gt;networking&lt;/code&gt; property. A default initializer taking &lt;code&gt;networking&lt;/code&gt; is implicitly created by Swift. Now &lt;code&gt;WeatherFetcher&lt;/code&gt; has no dependency on Alamofire.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcher.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct WeatherFetcher {
    let networking: Networking

    func fetch(response: [City]? -&amp;gt; ()) {
        networking.request { data in
            let cities = data.map { self.decode($0) }
            response(cities)
        }
    }

    private func decode(data: NSData) -&amp;gt; [City] {
        let json = JSON(data: data)
        var cities = [City]()
        for (_, j) in json[&amp;quot;list&amp;quot;] {
            if let id = j[&amp;quot;id&amp;quot;].int {
                let city = City(
                    id: id,
                    name: j[&amp;quot;name&amp;quot;].string ?? &amp;quot;&amp;quot;,
                    weather: j[&amp;quot;weather&amp;quot;][0][&amp;quot;main&amp;quot;].string ?? &amp;quot;&amp;quot;)
                cities.append(city)
            }
        }
        return cities
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify &lt;code&gt;WeatherFetcherSpec&lt;/code&gt; to test the decoupled network and JSON parser.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcherSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Swinject
@testable import SwinjectSimpleExample

class WeatherFetcherSpec: QuickSpec {
    struct StubNetwork: Networking {
        private static let json =
        &amp;quot;{&amp;quot; +
            &amp;quot;\&amp;quot;list\&amp;quot;: [&amp;quot; +
                &amp;quot;{&amp;quot; +
                    &amp;quot;\&amp;quot;id\&amp;quot;: 2643743,&amp;quot; +
                    &amp;quot;\&amp;quot;name\&amp;quot;: \&amp;quot;London\&amp;quot;,&amp;quot; +
                    &amp;quot;\&amp;quot;weather\&amp;quot;: [&amp;quot; +
                        &amp;quot;{&amp;quot; +
                            &amp;quot;\&amp;quot;main\&amp;quot;: \&amp;quot;Rain\&amp;quot;&amp;quot; +
                        &amp;quot;}&amp;quot; +
                    &amp;quot;]&amp;quot; +
                &amp;quot;},&amp;quot; +
                &amp;quot;{&amp;quot; +
                    &amp;quot;\&amp;quot;id\&amp;quot;: 3451190,&amp;quot; +
                    &amp;quot;\&amp;quot;name\&amp;quot;: \&amp;quot;Rio de Janeiro\&amp;quot;,&amp;quot; +
                    &amp;quot;\&amp;quot;weather\&amp;quot;: [&amp;quot; +
                        &amp;quot;{&amp;quot; +
                            &amp;quot;\&amp;quot;main\&amp;quot;: \&amp;quot;Clear\&amp;quot;&amp;quot; +
                        &amp;quot;}&amp;quot; +
                    &amp;quot;]&amp;quot; +
                &amp;quot;}&amp;quot; +
            &amp;quot;]&amp;quot; +
        &amp;quot;}&amp;quot;

        func request(response: NSData? -&amp;gt; ()) {
            let data = StubNetwork.json.dataUsingEncoding(
                NSUTF8StringEncoding, allowLossyConversion: false)
            response(data)
        }
    }

    override func spec() {
        var container: Container!
        beforeEach {
            container = Container()

            // Registrations for the network using Alamofire.
            container.register(Networking.self) { _ in Network() }
            container.register(WeatherFetcher.self) { r in
                WeatherFetcher(networking: r.resolve(Networking.self)!)
            }

            // Registration for the stub network.
            container.register(Networking.self, name: &amp;quot;stub&amp;quot;) { _ in
                StubNetwork()
            }
            container.register(WeatherFetcher.self, name: &amp;quot;stub&amp;quot;) { r in
                WeatherFetcher(
                    networking: r.resolve(Networking.self, name: &amp;quot;stub&amp;quot;)!)
            }
        }

        it(&amp;quot;returns cities.&amp;quot;) {
            var cities: [City]?
            let fetcher = container.resolve(WeatherFetcher.self)!
            fetcher.fetch { cities = $0 }

            expect(cities).toEventuallyNot(beNil())
            expect(cities?.count).toEventually(beGreaterThan(0))
        }
        it(&amp;quot;fills weather data.&amp;quot;) {
            var cities: [City]?
            let fetcher = container.resolve(WeatherFetcher.self, name: &amp;quot;stub&amp;quot;)!
            fetcher.fetch { cities = $0 }

            expect(cities?[0].id).toEventually(equal(2643743))
            expect(cities?[0].name).toEventually(equal(&amp;quot;London&amp;quot;))
            expect(cities?[0].weather).toEventually(equal(&amp;quot;Rain&amp;quot;))
            expect(cities?[1].id).toEventually(equal(3451190))
            expect(cities?[1].name).toEventually(equal(&amp;quot;Rio de Janeiro&amp;quot;))
            expect(cities?[1].weather).toEventually(equal(&amp;quot;Clear&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StubNetwork&lt;/code&gt; is a stub that conforms &lt;code&gt;Networking&lt;/code&gt;. It has a definition of JSON data that has the same structure as the data returned from the server. Its &lt;code&gt;request&lt;/code&gt; method returns the identical data any time regardless of the current weather in the real world. In &lt;code&gt;spec&lt;/code&gt;, &lt;code&gt;container&lt;/code&gt; is configured at the beginning, and it is used later in the two &lt;code&gt;it&lt;/code&gt; specifications. Without a registration name, &lt;code&gt;container&lt;/code&gt; is configured to use &lt;code&gt;Network&lt;/code&gt;. With the registration name &amp;ldquo;stub&amp;rdquo;, it is configured to use &lt;code&gt;StubNetwork&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first &lt;code&gt;it&lt;/code&gt; tests that the real network through Alamofire returns some JSON data&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; by getting an instance of &lt;code&gt;WeatherFetcher&lt;/code&gt; from &lt;code&gt;container&lt;/code&gt; without a registration name. We do not test detail of &lt;code&gt;cities&lt;/code&gt;. We just confirm that &lt;code&gt;fetch&lt;/code&gt; can get some data from the server.&lt;/p&gt;

&lt;p&gt;The second &lt;code&gt;it&lt;/code&gt; tests that the JSON data are parsed correctly by getting an instance of &lt;code&gt;WeatherFetcher&lt;/code&gt; with the registration name &amp;ldquo;stub&amp;rdquo;. Because the stub returns two cities as defined in &lt;code&gt;StubNetwork&lt;/code&gt;, we write expectations for the two cities and check whether each expectation asynchronously gets the value specified in the stub definition.&lt;/p&gt;

&lt;p&gt;Okay. We are ready to run the tests. Type &lt;code&gt;Command-U&lt;/code&gt; to run. This time you got the tests passed regardless of the current weather, didn&amp;rsquo;t you? This is the advantage of the dependency injection pattern to decouple a component from another, in this example decoupling of the parser component from network component.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The problem of dependencies to write unit tests has been explained and fixed with dependency injection in the scenario to develop the app using the network service and JSON parser. By decoupling these two parts, the unit tests have become reproducible under any circumstances. In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/&#34;&gt;the next blog post&lt;/a&gt;, we will develop the UI part of the example app to learn how to use Swinject in a product app.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;UI tests are excluded because still Xcode 7 is beta (just caring NDA). This blog post will be updated to include them after Xcode 7 is officially released.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;&lt;code&gt;Podfile&lt;/code&gt; in this blog post will be updated after Xcode 7 is officially released.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;Actually this setting is not preferable if you develop an app to release. In this blog post, I used the setting just because the free API only supports HTTP.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;This test may fail if the network is disconnected or has a problem, but these cases can be practically ignored in our unit tests.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection Framework for Swift - Introduction to Swinject</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-introduction-to-swinject/</link>
      <pubDate>Tue, 11 Aug 2015 13:20:41 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-introduction-to-swinject/</guid>
      <description>

&lt;p&gt;This blog post introduces &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, a dependency injection framework for Swift. Swift 2 will come with &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521&#34;&gt;protocol extension&lt;/a&gt; and encourage &lt;a href=&#34;https://developer.apple.com/videos/wwdc/2015/?id=408&#34;&gt;protocol oriented programming&lt;/a&gt;. In addition, Xcode 7 will introduce &lt;a href=&#34;https://developer.apple.com/videos/wwdc/2015/?id=406&#34;&gt;UI testing&lt;/a&gt;. In this context, it is getting more important to decouple components of an app by protocols. The typical pattern of the decoupling is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_injection&#34;&gt;dependency injection&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;dependency-injection:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Dependency Injection&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with an example. You are going to develop an app that lists current weather of some locations like the screenshot image below. The weather information will be received from a server through an API, and the data are used to present in the table view. Of course you will write unit tests. According to the screenshot, the tests will expect that the weather in Montreal&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; should be &amp;ldquo;Clouds&amp;rdquo;, in Moscow &amp;ldquo;Clear&amp;rdquo; and in Los Angeles &amp;ldquo;Clouds&amp;rdquo;, but wait, if you write test code like that, will the tests pass tomorrow too? They will rarely pass because the weather changes.&lt;/p&gt;

&lt;p&gt;The problem here is that the parts of network access and data processing are coupled. In other words, the data processing depends on the network access. If the dependency is hard-coded, it is difficult to write unit tests around the dependency. To solve the problem, the dependency should be passed from somewhere else. This is the dependency injection (DI) pattern. The external code provides dependencies to the client code. The injector is called DI container or simply container&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;swinject:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Swinject&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt; is a lightweight dependency injection framework written in Swift to use with Swift. The framework APIs are easy to learn and use because of the generic type and first class function features of Swift. Swinject is available through &lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; or &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;installation-with-cocoapods:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Installation with CocoaPods&lt;/h3&gt;

&lt;p&gt;To install Swinject with CocoaPods, add the following lines to your &lt;code&gt;Podfile&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;
platform :ios, &#39;8.0&#39;
use_frameworks!

pod &#39;Swinject&#39;, &#39;~&amp;gt; 0.2.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run &lt;code&gt;pod install&lt;/code&gt; command. For details of the installation and usage of CocoaPods, visit &lt;a href=&#34;https://cocoapods.org&#34;&gt;its official website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Later in the example app, we will use CocoaPods to install Swinject.&lt;/p&gt;

&lt;h3 id=&#34;installation-with-carthage:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Installation with Carthage&lt;/h3&gt;

&lt;p&gt;To install Swinject with Carthage, add the following line to your &lt;code&gt;Cartfile&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github &amp;quot;Swinject/Swinject&amp;quot; ~&amp;gt; 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run &lt;code&gt;carthage update&lt;/code&gt; command. For details of the installation and usage of Carthage, visit &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;its project page&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;basics:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Basics&lt;/h2&gt;

&lt;p&gt;Before continuing to details of the example app, let me introduce the basics of dependency injection with Swinject. Its project has a playground and it is easy to try dependency injection with Swinject. Download &lt;a href=&#34;https://github.com/Swinject/Swinject/releases&#34;&gt;the source code&lt;/a&gt; or clone &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;the project&lt;/a&gt;, and open the project file to use the playground.&lt;/p&gt;

&lt;h3 id=&#34;without-dependency-injection:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Without Dependency Injection&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say we are writing a game to play with animals. First we will write the program without dependency injection. Here is &lt;code&gt;Cat&lt;/code&gt; class to represent an animal,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Cat {
    let name: String

    init(name: String) {
        self.name = name
    }

    func sound() -&amp;gt; String {
        return &amp;quot;Meow!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;PetOwner&lt;/code&gt; class has an instance of &lt;code&gt;Cat&lt;/code&gt; as a pet to play with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PetOwner {
    let pet = Cat(name: &amp;quot;Mimi&amp;quot;)

    func play() -&amp;gt; String {
        return &amp;quot;I&#39;m playing with \(pet.name). \(pet.sound())&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can instantiate &lt;code&gt;PetOwner&lt;/code&gt; to play.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let petOwner = PetOwner()
print(petOwner.play()) // prints &amp;quot;I&#39;m playing with Mimi. Meow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is great if everyone is a cat person, but in reality some are dog persons. Because the instantiation of a &lt;code&gt;Cat&lt;/code&gt; is hard-coded, &lt;code&gt;PetOwner&lt;/code&gt; class depends on &lt;code&gt;Cat&lt;/code&gt; class. The dependency must be decoupled to support &lt;code&gt;Dog&lt;/code&gt; or other classes.&lt;/p&gt;

&lt;h3 id=&#34;with-dependency-injection:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;With Dependency Injection&lt;/h3&gt;

&lt;p&gt;Now is the time to start taking advantage of dependency injection. Here we are going to introduce &lt;code&gt;AnimalType&lt;/code&gt; protocol to get rid of the dependency.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol AnimalType {
    var name: String { get }
    func sound() -&amp;gt; String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Cat&lt;/code&gt; class is modified to conform the protocol,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Cat: AnimalType {
    let name: String

    init(name: String) {
        self.name = name
    }

    func sound() -&amp;gt; String {
        return &amp;quot;Meow!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;PetOwner&lt;/code&gt; class is modified to get an &lt;code&gt;AnimalType&lt;/code&gt; injected through its initializer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PetOwner {
    let pet: AnimalType

    init(pet: AnimalType) {
        self.pet = pet
    }

    func play() -&amp;gt; String {
        return &amp;quot;I&#39;m playing with \(pet.name). \(pet.sound())&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can inject the dependency to &lt;code&gt;AnimalType&lt;/code&gt; protocol when a &lt;code&gt;PetOwner&lt;/code&gt; instance is created.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let catOwner = PetOwner(pet: Cat(name: &amp;quot;Mimi&amp;quot;))
print(catOwner.play()) // prints &amp;quot;I&#39;m playing with Mimi. Meow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we have &lt;code&gt;Dog&lt;/code&gt; class,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dog: AnimalType {
    let name: String

    init(name: String) {
        self.name = name
    }

    func sound() -&amp;gt; String {
        return &amp;quot;Bow wow!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can play with a dog too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let dogOwner = PetOwner(pet: Dog(name: &amp;quot;Hachi&amp;quot;))
print(dogOwner.play()) // prints &amp;quot;I&#39;m playing with Hachi. Bow wow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, we injected the dependency of &lt;code&gt;PetOwner&lt;/code&gt; by ourselves, but if we get more dependencies as the app evolved, it is harder to maintain dependency injection by hand. Let&amp;rsquo;s introduce Swinject to manage the dependencies here.&lt;/p&gt;

&lt;p&gt;To use Swinject, add the following line to a playground or source code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Swinject
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create an instance of &lt;code&gt;Container&lt;/code&gt; and register the dependency.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let container = Container()
container.register(AnimalType.self) { _ in Cat(name: &amp;quot;Mimi&amp;quot;) }
container.register(PetOwner.self) { r in
    PetOwner(pet: r.resolve(AnimalType.self)!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, we told the &lt;code&gt;container&lt;/code&gt; to resolve &lt;code&gt;AnimalType&lt;/code&gt; to a &lt;code&gt;Cat&lt;/code&gt; instance named &amp;ldquo;Mimi&amp;rdquo;, and &lt;code&gt;PetOwner&lt;/code&gt; to an instance with an &lt;code&gt;AnimalType&lt;/code&gt; as a pet resolved by the &lt;code&gt;container&lt;/code&gt;. The &lt;code&gt;resolve&lt;/code&gt; method returns nil if the container cannot resolve an instance, but here we know &lt;code&gt;AnimalType&lt;/code&gt; is already registered and force-unwrap the optional parameter.&lt;/p&gt;

&lt;p&gt;We have got the configured container. Let&amp;rsquo;s get an instance of &lt;code&gt;PetOwner&lt;/code&gt; from the &lt;code&gt;container&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let petOwner = container.resolve(PetOwner.self)!
print(petOwner.play()) // prints &amp;quot;I&#39;m playing with Mimi. Meow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is so simple to configure a &lt;code&gt;Container&lt;/code&gt; and to retrieve a resolved instance with its dependencies injected.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The concept of dependency injection has been introduced with the scenario to write unit tests for the weather app, and its basic use case has been demonstrated. With Swinject, it is easy to configure the dependencies and to get instances with the dependencies resolved. &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;In the next blog post&lt;/a&gt;, we will see how to use Swinject with unit tests in the example weather app.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;The cities listed in the example app are the summer Olympic host cities since 1976.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;DI container is also called assembler, provider, builder, spring or injector.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;Specify version 0.1.0 if you use Xcode 6.4. Version 0.2 is required for Xcode 7 beta.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;Specify version 0.1 if you use Xcode 6.4. Version 0.2 is required for Xcode 7 beta.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>