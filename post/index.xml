<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Swift Injection</title>
    <link>https://yoichitgy.github.io/post/</link>
    <description>Recent content in Posts on Swift Injection</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 14 Aug 2015 17:14:24 +0900</lastBuildDate>
    <atom:link href="https://yoichitgy.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Dependency Injection Framework for Swift - Simple Weather App Example with Swinject Part 2/2</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/</link>
      <pubDate>Fri, 14 Aug 2015 17:14:24 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the last blog post&lt;/a&gt;, we developed the model part of the simple weather app, and learnt how to remove tightly coupled dependencies by using dependency injection and &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;. We found the decoupling made unit testing easier. In this blog post, we are going to develop the UI part of the app, and will learn how to wire up the decoupled components with Swinject.&lt;/p&gt;

&lt;p&gt;The source code used in this blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectSimpleExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;basic-ui-structure:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Basic UI Structure&lt;/h2&gt;

&lt;p&gt;First, we are going to make a basic UI structure to show the weather information in a table view. The UI components will be instantiated from a storyboard, but instantiation of the storyboard itself will be written by hand to use &lt;code&gt;SwinjectStoryboard&lt;/code&gt; inheriting &lt;code&gt;UIStoryboard&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Open &lt;code&gt;Info.plist&lt;/code&gt; and remove &lt;code&gt;&amp;quot;Main storyboard file base name&amp;quot;&lt;/code&gt; key, which might be displayed as &lt;code&gt;&amp;quot;UIMainStoryboardFile&amp;quot;&lt;/code&gt; if you are showing raw keys.&lt;/p&gt;

&lt;p&gt;Remove &lt;code&gt;ViewController.swift&lt;/code&gt; and add &lt;code&gt;WeatherTableViewController.swift&lt;/code&gt;, which has an empty definition of &lt;code&gt;WeatherTableViewController&lt;/code&gt;. We will implement the class later with the dependency injection pattern.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit

class WeatherTableViewController: UITableViewController {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open &lt;code&gt;Main.storyboard&lt;/code&gt; and remove the existing view controller. Then add a new navigation controller to the storyboard from the object library pane.&lt;/p&gt;

&lt;p&gt;Select the navigation controller and check &lt;code&gt;&amp;quot;Is Initial View Controller&amp;quot;&lt;/code&gt; in the attribute inspector.&lt;/p&gt;

&lt;p&gt;Select the table view controller, which is the root view controller of the navigation controller, and set its custom class to &lt;code&gt;WeatherTableViewController&lt;/code&gt;. Select the prototype cell on the table view, and set its style to &lt;code&gt;Right Detail&lt;/code&gt; and identifier to &lt;code&gt;&amp;quot;Cell&amp;quot;&lt;/code&gt;. Select the navigation item on the table view controller, and set its title to &lt;code&gt;&amp;quot;Weather Now&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleStoryboardScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Storyboard Screenshot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Modify &lt;code&gt;AppDelegate.swift&lt;/code&gt; to instantiate the initial view controller from the storyboard by hand. Here, we use &lt;code&gt;SwinjectStoryboard&lt;/code&gt; instead of &lt;code&gt;UIStoryboard&lt;/code&gt; to add dependency injection later. The instantiation of &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is not performed with a initializer but &lt;code&gt;create&lt;/code&gt;  function&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import UIKit
import Swinject

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(
        application: UIApplication,
        didFinishLaunchingWithOptions
        launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
    {
        let window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window.backgroundColor = UIColor.whiteColor()
        window.makeKeyAndVisible()
        self.window = window

        let storyboard = SwinjectStoryboard.create(name: &amp;quot;Main&amp;quot;, bundle: nil)
        window.rootViewController = storyboard.instantiateInitialViewController()

        return true
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we are ready to run the app. Type &lt;code&gt;Command-R&lt;/code&gt; to run. You will see an empty table view like the following image.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleEmptyScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Empty Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;dependency-injection-to-view-controller:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Dependency Injection to View Controller&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement the empty table view controller and add dependency injection to it.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;weatherFetcher&lt;/code&gt; property to &lt;code&gt;WeatherTableViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class WeatherTableViewController: UITableViewController {
    var weatherFetcher: WeatherFetcher?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify &lt;code&gt;AppDelegate&lt;/code&gt; to instantiate &lt;code&gt;SwinjectStoryboard&lt;/code&gt; with a configured &lt;code&gt;Container&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AppDelegate.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    var window: UIWindow?

    func application(
        application: UIApplication,
        didFinishLaunchingWithOptions
        launchOptions: [NSObject: AnyObject]?) -&amp;gt; Bool
    {
        let window = UIWindow(frame: UIScreen.mainScreen().bounds)
        window.backgroundColor = UIColor.whiteColor()
        window.makeKeyAndVisible()
        self.window = window

        let container = createContainer()
        let storyboard = SwinjectStoryboard.create(
            name: &amp;quot;Main&amp;quot;,
            bundle: nil,
            container: container)
        window.rootViewController = storyboard.instantiateInitialViewController()

        return true
    }

    private func createContainer() -&amp;gt; Container {
        let container = Container()
        container.registerForStoryboard(WeatherTableViewController.self) { r, c in
            c.weatherFetcher = r.resolve(WeatherFetcher.self)
        }
        container.register(Networking.self) { _ in Network() }
        container.register(WeatherFetcher.self) { r in
            WeatherFetcher(networking: r.resolve(Networking.self)!)
        }
        return container
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;createContainer&lt;/code&gt; method, first, a &lt;code&gt;Container&lt;/code&gt; instance is created, then configured. &lt;code&gt;registerForStoryboard&lt;/code&gt; is used to configure dependencies of a view controller. Here &lt;code&gt;WeatherTableViewController&lt;/code&gt; is configured to get &lt;code&gt;weatherFetcher&lt;/code&gt; property set to a resolved instance of &lt;code&gt;WeatherFetcher&lt;/code&gt;. This is called &amp;ldquo;property injection&amp;rdquo;. &lt;code&gt;Networking&lt;/code&gt; protocol, which was defined in &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;the last blog post&lt;/a&gt;, is configured to be &lt;code&gt;Network&lt;/code&gt; encapsulating Alamofire. &lt;code&gt;WeatherFetcher&lt;/code&gt; is configured to be initialized with a resolved &lt;code&gt;Networking&lt;/code&gt; instance. This is called &amp;ldquo;initializer injection&amp;rdquo;. At the end, the method returns the configured &lt;code&gt;container&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; method, the configured &lt;code&gt;container&lt;/code&gt; is passed to &lt;code&gt;SwinjectStoryboard&lt;/code&gt;. That&amp;rsquo;s all. Simple, isn&amp;rsquo;t it? Just configured and passed it.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s move on to the implementation of &lt;code&gt;WeatherTableViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewController.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class WeatherTableViewController: UITableViewController {
    var weatherFetcher: WeatherFetcher?

    private var cities = [City]() {
        didSet {
            tableView.reloadData()
        }
    }

    override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(animated)

        weatherFetcher?.fetch {
            if let cities = $0 {
                self.cities = cities
            }
            else {
                // Show an error message.
            }
        }
    }

    // MARK: UITableViewDataSource
    override func tableView(
        tableView: UITableView,
        numberOfRowsInSection section: Int) -&amp;gt; Int
    {
        return cities.count
    }

    override func tableView(
        tableView: UITableView,
        cellForRowAtIndexPath indexPath: NSIndexPath) -&amp;gt; UITableViewCell
    {
        let cell = tableView.dequeueReusableCellWithIdentifier(
            &amp;quot;Cell&amp;quot;, forIndexPath: indexPath)
        let city = cities[indexPath.row]
        cell.textLabel?.text = city.name
        cell.detailTextLabel?.text = city.weather
        return cell
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, &lt;code&gt;cities&lt;/code&gt; property is added with an initial empty array of &lt;code&gt;City&lt;/code&gt;. Setting the property triggers refreshing the table view.&lt;/p&gt;

&lt;p&gt;Second, &lt;code&gt;viewWillAppear&lt;/code&gt; is overridden to start fetching weather information by &lt;code&gt;fetch&lt;/code&gt; method&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;. It takes a closure, and invokes the closure with an array of &lt;code&gt;City&lt;/code&gt; when the weather data are retrieved. In the closure, &lt;code&gt;self.cities&lt;/code&gt; is set and the table view is refreshed consequently. If &lt;code&gt;fetch&lt;/code&gt; fails, it passes &lt;code&gt;nil&lt;/code&gt; to the closure. In this blog post, the error handling is omitted, but the source code in &lt;a href=&#34;https://github.com/Swinject/SwinjectSimpleExample&#34;&gt;the GitHub repository&lt;/a&gt; has an implementation to show an error message.&lt;/p&gt;

&lt;p&gt;At last, &lt;code&gt;tableView:numberOfRowsInSection:&lt;/code&gt; and &lt;code&gt;tableView:cellForRowAtIndexPath:&lt;/code&gt; are implemented to tell the number of rows and to set city name and weather labels of a cell.&lt;/p&gt;

&lt;p&gt;We have finished implementing the UI. Let&amp;rsquo;s run the app. You will see the table view filled with current weather information.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;testing-view-controller:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Testing View Controller&lt;/h2&gt;

&lt;p&gt;We have already seen the app works, but let me add a unit test for &lt;code&gt;WeatherTableViewController&lt;/code&gt;. We are going to check the view controller starts fetching weather data when the view appears. In this test, we will see the concept of &lt;a href=&#34;https://en.wikipedia.org/wiki/Mock_object&#34;&gt;mocking&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;WeatherTableViewControllerSpec.swift&lt;/code&gt; to &lt;code&gt;SwinjectSimpleExampleTests&lt;/code&gt; with the following content.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherTableViewControllerSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Swinject
@testable import SwinjectSimpleExample

class WeatherTableViewControllerSpec: QuickSpec {
    class MockNetwork: Networking {
        var requestCount = 0

        func request(response: NSData? -&amp;gt; ()) {
            requestCount++
        }
    }

    override func spec() {
        var container: Container!
        beforeEach {
            container = Container()
            container.register(Networking.self) { _ in MockNetwork() }
                .inObjectScope(.Container)
            container.register(WeatherFetcher.self) { r in
                WeatherFetcher(networking: r.resolve(Networking.self)!)
            }
            container.register(WeatherTableViewController.self) { r in
                let controller = WeatherTableViewController()
                controller.weatherFetcher = r.resolve(WeatherFetcher.self)
                return controller
            }
        }

        it(&amp;quot;starts fetching weather information when the view is about appearing.&amp;quot;) {
            let network = container.resolve(Networking.self) as! MockNetwork
            let controller = container.resolve(WeatherTableViewController.self)!

            expect(network.requestCount) == 0
            controller.viewWillAppear(true)
            expect(network.requestCount).toEventually(equal(1))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the beginning, a mock of &lt;code&gt;Networking&lt;/code&gt; is defined as &lt;code&gt;MockNetwork&lt;/code&gt;. It has &lt;code&gt;request&lt;/code&gt; method, but never returns a response. Instead, it increments a counter named &lt;code&gt;requestCount&lt;/code&gt;. A mock is used to check whether methods or properties of an instance are called as intended. Although it may return dummy data like a stub does, the ability to check method or property calls differentiates a mock from a stub.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;spec&lt;/code&gt;, we skip to &lt;code&gt;it&lt;/code&gt; for now. First, instances of &lt;code&gt;MockNetwork&lt;/code&gt; and &lt;code&gt;WeatherTableViewController&lt;/code&gt; are retrieved from the configured &lt;code&gt;container&lt;/code&gt;. Because we know &lt;code&gt;Networking&lt;/code&gt; is resolved to &lt;code&gt;MockNetwork&lt;/code&gt;, we cast the returned instance to &lt;code&gt;MockNetwork&lt;/code&gt;. Then, it is checked, by the &lt;code&gt;requestCount&lt;/code&gt; counter, that &lt;code&gt;request&lt;/code&gt; method of the mock is called once after &lt;code&gt;viewWillAppear&lt;/code&gt; of the view controller is called. Although &lt;code&gt;WeatherTableViewController&lt;/code&gt; does not directly own &lt;code&gt;Networking&lt;/code&gt; instance, we can ensure related instances are connected correctly by checking the call of the mocked method.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s go back to the configuration of the &lt;code&gt;container&lt;/code&gt;. First, &lt;code&gt;Networking&lt;/code&gt; is registered to be resolved to &lt;code&gt;MockNetwork&lt;/code&gt;, and its instance is configured to be shared within the &lt;code&gt;container&lt;/code&gt;. By setting the object scope, it is ensured that the instance of &lt;code&gt;MockNetwork&lt;/code&gt; to check the counter is identical to the instance indirectly owned by &lt;code&gt;WeatherTableViewController&lt;/code&gt;. Second, initializer injection of &lt;code&gt;WeatherFetcher&lt;/code&gt; dependency is registered. Third, property injection of &lt;code&gt;WeatherTableViewController&lt;/code&gt; dependency is registered.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s run the unit test. Passed, right? Assume you keep developing the weather app to add more features. The unit test gives you confidence that you will never break the connection of the UI and model.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:524204bd8810b54f3a02dbb14a1eb96e&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We have developed the UI part of the simple weather app, and learnt how to wire the components with a dependency injection container. &lt;code&gt;SwinjectStoryboard&lt;/code&gt; makes it easy to inject dependencies to view controllers defined in a storyboard. We have learnt, at last, a mock can be used to ensure that the components are wired as intended by checking a method call to the instance located at the terminal of the chain of dependencies.&lt;/p&gt;

&lt;p&gt;In the next blog post, we will develop a larger example app in &lt;a href=&#34;https://en.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVM&lt;/a&gt; architecture with the popular and elegant Swift &lt;a href=&#34;https://en.wikipedia.org/wiki/Reactive_programming&#34;&gt;reactive programming&lt;/a&gt; framework, &lt;a href=&#34;https://github.com/ReactiveCocoa/ReactiveCocoa&#34;&gt;ReactiveCococa&lt;/a&gt;. Of course, we will take advantage of dependency injection with Swinject to wire up the loosely coupled MVVM components.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;The instantiation of &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is a bit tricky because &lt;code&gt;UIStoryboard&lt;/code&gt; does not have a normal designated initializer to override by its child classes. To workaround this problem, &lt;code&gt;SwinjectStoryboard&lt;/code&gt; is instantiated with &lt;code&gt;create&lt;/code&gt; function instead of an initializer.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:524204bd8810b54f3a02dbb14a1eb96e:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;In the example app, &lt;code&gt;fetch&lt;/code&gt; is called only in &lt;code&gt;viewWillAppear&lt;/code&gt;, but a product app should have a button or something else to refresh the weather information.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:524204bd8810b54f3a02dbb14a1eb96e:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection Framework for Swift - Simple Weather App Example with Swinject Part 1/2</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/</link>
      <pubDate>Thu, 13 Aug 2015 09:16:58 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/</guid>
      <description>

&lt;p&gt;In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-introduction-to-swinject/&#34;&gt;the last blog post&lt;/a&gt;, we walked through the concept of dependency injection and basic usage of &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, the dependency injection framework for Swift. In this blog post, we are going to develop the simple weather app that you saw its screenshot in the last blog post. During the simple but essential steps of the development, you will see how to get rid of tightly coupled dependencies by using the dependency injection pattern and Swinject.&lt;/p&gt;

&lt;p&gt;The source code used in this blog post is available at &lt;a href=&#34;https://github.com/Swinject/SwinjectSimpleExample&#34;&gt;a repository on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;requirements:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Requirements&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Xcode 7 (beta)&lt;/li&gt;
&lt;li&gt;OpenWeatherMap API key&lt;/li&gt;
&lt;li&gt;CocoaPods 0.38 or later&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are going to use Xcode 7 although it is still beta. It is beta 5 at the timing of writing this blog post. Xcode 7 supports &lt;code&gt;@testable import&lt;/code&gt; to access &lt;code&gt;internal&lt;/code&gt; types, functions or properties in unit test targets.&lt;/p&gt;

&lt;p&gt;Also, we will use &lt;a href=&#34;http://openweathermap.org&#34;&gt;OpenWeatherMap&lt;/a&gt; for a free API to get weather information. &lt;a href=&#34;http://home.openweathermap.org/users/sign_up&#34;&gt;Sign up&lt;/a&gt; and get a free API key.&lt;/p&gt;

&lt;p&gt;To install Swinject and some frameworks, we will use &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;preparation-of-the-project:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Preparation of the Project&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with a new Xcode project. Select &lt;code&gt;File &amp;gt; New &amp;gt; Project...&lt;/code&gt; menu and &lt;code&gt;iOS &amp;gt; Application &amp;gt; Single View Application&lt;/code&gt; item. Set  its product name to &lt;code&gt;SwinjectSimpleExample&lt;/code&gt;, language to Swift and devices to iPhone. Check &lt;code&gt;Include Unit Tests&lt;/code&gt; only&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, then save it anywhere in your local storage.&lt;/p&gt;

&lt;p&gt;Then, we are going to install &lt;a href=&#34;https://github.com/Alamofire/Alamofire&#34;&gt;Alamofire&lt;/a&gt;, &lt;a href=&#34;https://github.com/SwiftyJSON/SwiftyJSON&#34;&gt;SwiftyJSON&lt;/a&gt;, &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, &lt;a href=&#34;https://github.com/Quick/Quick&#34;&gt;Quick&lt;/a&gt; and &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt; with &lt;a href=&#34;https://cocoapods.org&#34;&gt;CocoaPods&lt;/a&gt;. Create &lt;code&gt;Podfile&lt;/code&gt; with the following text content in the project root directory. Then run &lt;code&gt;pod install&lt;/code&gt; command to install them. Since Xcode 7 is still beta, specific commits of Alamofire and SwiftyJSON are specified&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;
platform :ios, &#39;8.0&#39;
use_frameworks!

pod &#39;Alamofire&#39;, :git =&amp;gt; &#39;https://github.com/Alamofire/Alamofire.git&#39;, :commit =&amp;gt; &#39;1b7b1f1aa&#39;
pod &#39;SwiftyJSON&#39;, :git =&amp;gt; &#39;https://github.com/SwiftyJSON/SwiftyJSON.git&#39;, :commit =&amp;gt; &#39;45ca854ce&#39;
pod &#39;Swinject&#39;, &#39;~&amp;gt; 0.2&#39;

target &#39;SwinjectSimpleExampleTests&#39; do
    pod &#39;Quick&#39;, &#39;~&amp;gt; 0.5.0&#39;
    pod &#39;Nimble&#39;, &#39;2.0.0-rc.2&#39;
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alamofire is a networking library to write request and asynchronous response simply. SwiftyJSON is a library to access JSON elements simply. Quick is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Behavior-driven_development&#34;&gt;behavior-driven development&lt;/a&gt; framework to write tests as specs in simple structures. Nimble is a matcher framework that is expressive and supports asynchronous tests. For details, please visit their project pages.&lt;/p&gt;

&lt;p&gt;To use the free weather API on iOS 9, we have to allow HTTP connections. Open &lt;code&gt;Info.plist&lt;/code&gt; and add &lt;code&gt;NSAppTransportSecurity&lt;/code&gt; dictionary with &lt;code&gt;NSAllowsArbitraryLoads&lt;/code&gt; element set to &lt;code&gt;true&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.  &lt;a href=&#34;http://stackoverflow.com/questions/30720813/cfnetwork-sslhandshake-failed-ios-9&#34;&gt;Here&lt;/a&gt; is more information about the setting and its background.&lt;/p&gt;

&lt;h2 id=&#34;without-dependency-injection:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Without Dependency Injection&lt;/h2&gt;

&lt;p&gt;First, without dependency injection, we are going to implement a model to handle weather information retrieved through the network service. We will see what can be a problem if we do not care about coupled dependencies.&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;City.swift&lt;/code&gt; to &lt;code&gt;SwinjectSimpleExample&lt;/code&gt; group in the project. We define &lt;code&gt;City&lt;/code&gt; to be an entity representing a city with weather information.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;City.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct City {
    let id: Int
    let name: String
    let weather: String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;OpenWeatherMap.swift&lt;/code&gt; to store configurations of OpenWeatherMap API. Here please fill &lt;code&gt;apiKey&lt;/code&gt; with your own API key.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OpenWeatherMap.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct OpenWeatherMap {
    private static let apiKey = &amp;quot;YOUR API KEY HERE&amp;quot;

    private static let cityIds = [
        6077243, 524901, 5368361, 1835848, 3128760, 4180439,
        2147714, 264371, 1816670, 2643743, 3451190, 1850147
    ]

    static let url = &amp;quot;http://api.openweathermap.org/data/2.5/group&amp;quot;

    static var parameters: [String: String] {
        return [
            &amp;quot;APPID&amp;quot;: apiKey,
            &amp;quot;id&amp;quot;: &amp;quot;,&amp;quot;.join(cityIds.map { String($0) })
        ]
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;WeatherFetcher.swift&lt;/code&gt; to implement &lt;code&gt;WeatherFetcher&lt;/code&gt;, which has &lt;code&gt;fetch&lt;/code&gt; function taking a callback to handle an optional array of &lt;code&gt;Cities&lt;/code&gt; returned from OpenWeatherMap.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcher.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import Alamofire
import SwiftyJSON

struct WeatherFetcher {
    static func fetch(response: [City]? -&amp;gt; ()) {
        Alamofire.request(.GET, OpenWeatherMap.url, parameters: OpenWeatherMap.parameters)
            .response { _, _, data, _ in
                let cities = data.map { decode($0) }
                response(cities)
            }
    }

    private static func decode(data: NSData) -&amp;gt; [City] {
        let json = JSON(data: data)
        var cities = [City]()
        for (_, j) in json[&amp;quot;list&amp;quot;] {
            if let id = j[&amp;quot;id&amp;quot;].int {
                let city = City(
                    id: id,
                    name: j[&amp;quot;name&amp;quot;].string ?? &amp;quot;&amp;quot;,
                    weather: j[&amp;quot;weather&amp;quot;][0][&amp;quot;main&amp;quot;].string ?? &amp;quot;&amp;quot;)
                cities.append(city)
            }
        }
        return cities
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;fetch&lt;/code&gt; function uses Alamofire to send a request to the server and to get a response as JSON data asynchronously. The specifications of API call and response JSON format are described in &lt;a href=&#34;http://openweathermap.org/current#severalid&#34;&gt;&amp;ldquo;Call for several city IDs&amp;rdquo; section of OpenWeatherMap site&lt;/a&gt;.
The &lt;code&gt;data&lt;/code&gt; parameter in the closure passed to &lt;code&gt;response&lt;/code&gt; from &lt;code&gt;Alamofire&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the response has an error. We do not care about details of the error and just pass &lt;code&gt;nil&lt;/code&gt; to the callback to &lt;code&gt;fetch&lt;/code&gt; in this example although the error should be handled in a product app.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;decode&lt;/code&gt; function parses the JSON data returned from the server. It is called as &lt;code&gt;data.map { decode($0) }&lt;/code&gt; in &lt;code&gt;fetch&lt;/code&gt; where &lt;code&gt;map&lt;/code&gt; executes the trailing closure if &lt;code&gt;data&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt;, otherwise returns nil. The &lt;code&gt;decode&lt;/code&gt; function uses SwiftyJSON to map the JSON data to an array of our &lt;code&gt;City&lt;/code&gt; entities.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a unit test to &lt;code&gt;SwinjectSimpleExampleTests&lt;/code&gt; group in our project. The filename is &lt;code&gt;WeatherFetcherSpec.swift&lt;/code&gt; and its target is set to &lt;code&gt;SwinjectSimpleExampleTests&lt;/code&gt; when we create the file. The test is going to check whether the weather data can be retrieved and parsed correctly.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcherSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
@testable import SwinjectSimpleExample

class WeatherFetcherSpec: QuickSpec {
    override func spec() {
        it(&amp;quot;returns cities.&amp;quot;) {
            var cities: [City]?
            WeatherFetcher.fetch { cities = $0 }

            expect(cities).toEventuallyNot(beNil())
            expect(cities?.count).toEventually(equal(12))
            expect(cities?[0].id).toEventually(equal(6077243))
            expect(cities?[0].name).toEventually(equal(&amp;quot;Montreal&amp;quot;))
            expect(cities?[0].weather).toEventually(equal(&amp;quot;Clouds&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Quick and Nimble, each test is written in an &lt;code&gt;it&lt;/code&gt; closure, and each expectation is expressed as &lt;code&gt;expect(something).to(condition)&lt;/code&gt; or &lt;code&gt;expect(something).toNot(condition)&lt;/code&gt; synchronously, or &lt;code&gt;expect(something).toEventually(condition)&lt;/code&gt; or &lt;code&gt;expect(something).toEventuallyNot(condition)&lt;/code&gt; asynchronously. &lt;code&gt;WeatherFetcher.fetch&lt;/code&gt; sets &lt;code&gt;cities&lt;/code&gt; asynchronously when weather data is retrieved, so we use the latter ones here.&lt;/p&gt;

&lt;p&gt;First, we check &lt;code&gt;cities&lt;/code&gt;, which is initialized with &lt;code&gt;nil&lt;/code&gt;, should be set to an array after &lt;code&gt;fetch&lt;/code&gt; invokes the callback asynchronously. Second, the number of &lt;code&gt;cities&lt;/code&gt; should be &lt;code&gt;12&lt;/code&gt; because our request to the API has 12 city IDs. From the third to fifth, we check only the first city for simplicity. The &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;weather&lt;/code&gt; should be &lt;code&gt;6077243&lt;/code&gt;, &lt;code&gt;&amp;quot;Montreal&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;Clouds&amp;quot;&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Okay. We are ready to run the unit test. Type &lt;code&gt;Command-U&lt;/code&gt; to run. Did you see the test passed? I think some people saw it passed, but the others not. Why? Because the weather in &amp;ldquo;Montreal&amp;rdquo; in the real world right now must be &amp;ldquo;Clouds&amp;rdquo; to pass the test. How can we write a test passing regardless of the current weather? It is actually difficult to write if the part parsing JSON data depends on the part retrieving the data from the server.&lt;/p&gt;

&lt;h2 id=&#34;with-dependency-injection:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;With Dependency Injection&lt;/h2&gt;

&lt;p&gt;In the last section, we found the tightly coupled dependency of the parser on the network, namely Alamofire, made the test difficult. In this section, we are going to decouple them, inject the dependency and write a better test.&lt;/p&gt;

&lt;p&gt;First, add &lt;code&gt;Networking.swift&lt;/code&gt; with the following protocol definition. It has &lt;code&gt;request&lt;/code&gt; method taking a callback to pass response data from the network.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Networking.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

protocol Networking {
    func request(response: NSData? -&amp;gt; ())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add &lt;code&gt;Network.swift&lt;/code&gt; to implement &lt;code&gt;Network&lt;/code&gt; that conforms &lt;code&gt;Networking&lt;/code&gt; protocol. It encapsulates Alamofire.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Network.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import Alamofire

struct Network : Networking {
    func request(response: NSData? -&amp;gt; ()) {
        Alamofire.request(.GET, OpenWeatherMap.url, parameters: OpenWeatherMap.parameters)
            .response { _, _, data, _ in
                response(data)
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modify &lt;code&gt;WeatherFetcher&lt;/code&gt; to get &lt;code&gt;Networking&lt;/code&gt; injected when it is instantiated and to use it to request weather data to the server. Note that &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt; functions were &lt;code&gt;static&lt;/code&gt; in the last section, but here they are instance methods to use the &lt;code&gt;networking&lt;/code&gt; property. A default initializer taking &lt;code&gt;networking&lt;/code&gt; is implicitly created by Swift. Now &lt;code&gt;WeatherFetcher&lt;/code&gt; has no dependency on Alamofire.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcher.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct WeatherFetcher {
    let networking: Networking

    func fetch(response: [City]? -&amp;gt; ()) {
        networking.request { data in
            let cities = data.map { self.decode($0) }
            response(cities)
        }
    }

    private func decode(data: NSData) -&amp;gt; [City] {
        let json = JSON(data: data)
        var cities = [City]()
        for (_, j) in json[&amp;quot;list&amp;quot;] {
            if let id = j[&amp;quot;id&amp;quot;].int {
                let city = City(
                    id: id,
                    name: j[&amp;quot;name&amp;quot;].string ?? &amp;quot;&amp;quot;,
                    weather: j[&amp;quot;weather&amp;quot;][0][&amp;quot;main&amp;quot;].string ?? &amp;quot;&amp;quot;)
                cities.append(city)
            }
        }
        return cities
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then modify &lt;code&gt;WeatherFetcherSpec&lt;/code&gt; to test the decoupled network and JSON parser.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;WeatherFetcherSpec.swift&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Quick
import Nimble
import Swinject
@testable import SwinjectSimpleExample

class WeatherFetcherSpec: QuickSpec {
    struct StubNetwork: Networking {
        private static let json =
        &amp;quot;{&amp;quot; +
            &amp;quot;\&amp;quot;list\&amp;quot;: [&amp;quot; +
                &amp;quot;{&amp;quot; +
                    &amp;quot;\&amp;quot;id\&amp;quot;: 2643743,&amp;quot; +
                    &amp;quot;\&amp;quot;name\&amp;quot;: \&amp;quot;London\&amp;quot;,&amp;quot; +
                    &amp;quot;\&amp;quot;weather\&amp;quot;: [&amp;quot; +
                        &amp;quot;{&amp;quot; +
                            &amp;quot;\&amp;quot;main\&amp;quot;: \&amp;quot;Rain\&amp;quot;&amp;quot; +
                        &amp;quot;}&amp;quot; +
                    &amp;quot;]&amp;quot; +
                &amp;quot;},&amp;quot; +
                &amp;quot;{&amp;quot; +
                    &amp;quot;\&amp;quot;id\&amp;quot;: 3451190,&amp;quot; +
                    &amp;quot;\&amp;quot;name\&amp;quot;: \&amp;quot;Rio de Janeiro\&amp;quot;,&amp;quot; +
                    &amp;quot;\&amp;quot;weather\&amp;quot;: [&amp;quot; +
                        &amp;quot;{&amp;quot; +
                            &amp;quot;\&amp;quot;main\&amp;quot;: \&amp;quot;Clear\&amp;quot;&amp;quot; +
                        &amp;quot;}&amp;quot; +
                    &amp;quot;]&amp;quot; +
                &amp;quot;}&amp;quot; +
            &amp;quot;]&amp;quot; +
        &amp;quot;}&amp;quot;

        func request(response: NSData? -&amp;gt; ()) {
            let data = StubNetwork.json.dataUsingEncoding(
                NSUTF8StringEncoding, allowLossyConversion: false)
            response(data)
        }
    }

    override func spec() {
        var container: Container!
        beforeEach {
            container = Container()

            // Registrations for the network using Alamofire.
            container.register(Networking.self) { _ in Network() }
            container.register(WeatherFetcher.self) { r in
                WeatherFetcher(networking: r.resolve(Networking.self)!)
            }

            // Registration for the stub network.
            container.register(Networking.self, name: &amp;quot;stub&amp;quot;) { _ in
                StubNetwork()
            }
            container.register(WeatherFetcher.self, name: &amp;quot;stub&amp;quot;) { r in
                WeatherFetcher(
                    networking: r.resolve(Networking.self, name: &amp;quot;stub&amp;quot;)!)
            }
        }

        it(&amp;quot;returns cities.&amp;quot;) {
            var cities: [City]?
            let fetcher = container.resolve(WeatherFetcher.self)!
            fetcher.fetch { cities = $0 }

            expect(cities).toEventuallyNot(beNil())
            expect(cities?.count).toEventually(beGreaterThan(0))
        }
        it(&amp;quot;fills weather data.&amp;quot;) {
            var cities: [City]?
            let fetcher = container.resolve(WeatherFetcher.self, name: &amp;quot;stub&amp;quot;)!
            fetcher.fetch { cities = $0 }

            expect(cities?[0].id).toEventually(equal(2643743))
            expect(cities?[0].name).toEventually(equal(&amp;quot;London&amp;quot;))
            expect(cities?[0].weather).toEventually(equal(&amp;quot;Rain&amp;quot;))
            expect(cities?[1].id).toEventually(equal(3451190))
            expect(cities?[1].name).toEventually(equal(&amp;quot;Rio de Janeiro&amp;quot;))
            expect(cities?[1].weather).toEventually(equal(&amp;quot;Clear&amp;quot;))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StubNetwork&lt;/code&gt; is a stub that conforms &lt;code&gt;Networking&lt;/code&gt;. It has a definition of JSON data that has the same structure as the data returned from the server. Its &lt;code&gt;request&lt;/code&gt; method returns the identical data any time regardless of the current weather in the real world. In &lt;code&gt;spec&lt;/code&gt;, &lt;code&gt;container&lt;/code&gt; is configured at the beginning, and it is used later in the two &lt;code&gt;it&lt;/code&gt; specifications. Without a registration name, &lt;code&gt;container&lt;/code&gt; is configured to use &lt;code&gt;Network&lt;/code&gt;. With the registration name &amp;ldquo;stub&amp;rdquo;, it is configured to use &lt;code&gt;StubNetwork&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first &lt;code&gt;it&lt;/code&gt; tests that the real network through Alamofire returns some JSON data&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; by getting an instance of &lt;code&gt;WeatherFetcher&lt;/code&gt; from &lt;code&gt;container&lt;/code&gt; without a registration name. We do not test detail of &lt;code&gt;cities&lt;/code&gt;. We just confirm that &lt;code&gt;fetch&lt;/code&gt; can get some data from the server.&lt;/p&gt;

&lt;p&gt;The second &lt;code&gt;it&lt;/code&gt; tests that the JSON data are parsed correctly by getting an instance of &lt;code&gt;WeatherFetcher&lt;/code&gt; with the registration name &amp;ldquo;stub&amp;rdquo;. Because the stub returns two cities as defined in &lt;code&gt;StubNetwork&lt;/code&gt;, we write expectations for the two cities and check whether each expectation asynchronously gets the value specified in the stub definition.&lt;/p&gt;

&lt;p&gt;Okay. We are ready to run the tests. Type &lt;code&gt;Command-U&lt;/code&gt; to run. This time you got the tests passed regardless of the current weather, didn&amp;rsquo;t you? This is the advantage of the dependency injection pattern to decouple a component from another, in this example decoupling of the parser component from network component.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:929d1b9e13edd8ae673f74cad40c219d&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The problem of dependencies to write unit tests has been explained and fixed with dependency injection in the scenario to develop the app using the network service and JSON parser. By decoupling these two parts, the unit tests have become reproducible under any circumstances. In &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-2/&#34;&gt;the next blog post&lt;/a&gt;, we will develop the UI part of the example app to learn how to use Swinject in a product app.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;UI tests are excluded because still Xcode 7 is beta (just caring NDA). This blog post will be updated to include them after Xcode 7 is officially released.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;&lt;code&gt;Podfile&lt;/code&gt; in this blog post will be updated after Xcode 7 is officially released.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;Actually this setting is not preferable if you develop an app to release. In this blog post, I used the setting just because the free API only supports HTTP.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;This test may fail if the network is disconnected or has a problem, but these cases can be practically ignored in our unit tests.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:929d1b9e13edd8ae673f74cad40c219d:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Dependency Injection Framework for Swift - Introduction to Swinject</title>
      <link>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-introduction-to-swinject/</link>
      <pubDate>Tue, 11 Aug 2015 13:20:41 +0900</pubDate>
      
      <guid>https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-introduction-to-swinject/</guid>
      <description>

&lt;p&gt;This blog post introduces &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt;, a dependency injection framework for Swift. Swift 2 will come with &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID521&#34;&gt;protocol extension&lt;/a&gt; and encourage &lt;a href=&#34;https://developer.apple.com/videos/wwdc/2015/?id=408&#34;&gt;protocol oriented programming&lt;/a&gt;. In addition, Xcode 7 will introduce &lt;a href=&#34;https://developer.apple.com/videos/wwdc/2015/?id=406&#34;&gt;UI testing&lt;/a&gt;. In this context, it is getting more important to decouple components of an app by protocols. The typical pattern of the decoupling is called &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_injection&#34;&gt;dependency injection&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;dependency-injection:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Dependency Injection&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s start with an example. You are going to develop an app that lists current weather of some locations like the screenshot image below. The weather information will be received from a server through an API, and the data are used to present in the table view. Of course you will write unit tests. According to the screenshot, the tests will expect that the weather in Montreal&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; should be &amp;ldquo;Clouds&amp;rdquo;, in Moscow &amp;ldquo;Clear&amp;rdquo; and in Los Angeles &amp;ldquo;Clouds&amp;rdquo;, but wait, if you write test code like that, will the tests pass tomorrow too? They will rarely pass because the weather changes.&lt;/p&gt;

&lt;p&gt;The problem here is that the parts of network access and data processing are coupled. In other words, the data processing depends on the network access. If the dependency is hard-coded, it is difficult to write unit tests around the dependency. To solve the problem, the dependency should be passed from somewhere else. This is the dependency injection (DI) pattern. The external code provides dependencies to the client code. The injector is called DI container or simply container&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://yoichitgy.github.io/images/post/2015-08/SwinjectSimpleExampleScreenshot.png&#34; alt=&#34;SwinjectSimpleExample Screenshot&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;swinject:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Swinject&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;Swinject&lt;/a&gt; is a lightweight dependency injection framework written in Swift to use with Swift. The framework APIs are easy to learn and use because of the generic type and first class function features of Swift. Swinject is available through &lt;a href=&#34;https://cocoapods.org/&#34;&gt;CocoaPods&lt;/a&gt; or &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;Carthage&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;installation-with-cocoapods:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Installation with CocoaPods&lt;/h3&gt;

&lt;p&gt;To install Swinject with CocoaPods, add the following lines to your &lt;code&gt;Podfile&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source &#39;https://github.com/CocoaPods/Specs.git&#39;
platform :ios, &#39;8.0&#39;
use_frameworks!

pod &#39;Swinject&#39;, &#39;~&amp;gt; 0.2.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run &lt;code&gt;pod install&lt;/code&gt; command. For details of the installation and usage of CocoaPods, visit &lt;a href=&#34;https://cocoapods.org&#34;&gt;its official website&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Later in the example app, we will use CocoaPods to install Swinject.&lt;/p&gt;

&lt;h3 id=&#34;installation-with-carthage:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Installation with Carthage&lt;/h3&gt;

&lt;p&gt;To install Swinject with Carthage, add the following line to your &lt;code&gt;Cartfile&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;github &amp;quot;Swinject/Swinject&amp;quot; ~&amp;gt; 0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run &lt;code&gt;carthage update&lt;/code&gt; command. For details of the installation and usage of Carthage, visit &lt;a href=&#34;https://github.com/Carthage/Carthage&#34;&gt;its project page&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;basics:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Basics&lt;/h2&gt;

&lt;p&gt;Before continuing to details of the example app, let me introduce the basics of dependency injection with Swinject. Its project has a playground and it is easy to try dependency injection with Swinject. Download &lt;a href=&#34;https://github.com/Swinject/Swinject/releases&#34;&gt;the source code&lt;/a&gt; or clone &lt;a href=&#34;https://github.com/Swinject/Swinject&#34;&gt;the project&lt;/a&gt;, and open the project file to use the playground.&lt;/p&gt;

&lt;h3 id=&#34;without-dependency-injection:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Without Dependency Injection&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say we are writing a game to play with animals. First we will write the program without dependency injection. Here is &lt;code&gt;Cat&lt;/code&gt; class to represent an animal,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Cat {
    let name: String

    init(name: String) {
        self.name = name
    }

    func sound() -&amp;gt; String {
        return &amp;quot;Meow!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;PetOwner&lt;/code&gt; class has an instance of &lt;code&gt;Cat&lt;/code&gt; as a pet to play with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PetOwner {
    let pet = Cat(name: &amp;quot;Mimi&amp;quot;)

    func play() -&amp;gt; String {
        return &amp;quot;I&#39;m playing with \(pet.name). \(pet.sound())&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can instantiate &lt;code&gt;PetOwner&lt;/code&gt; to play.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let petOwner = PetOwner()
print(petOwner.play()) // prints &amp;quot;I&#39;m playing with Mimi. Meow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is great if everyone is a cat person, but in reality some are dog persons. Because the instantiation of a &lt;code&gt;Cat&lt;/code&gt; is hard-coded, &lt;code&gt;PetOwner&lt;/code&gt; class depends on &lt;code&gt;Cat&lt;/code&gt; class. The dependency must be decoupled to support &lt;code&gt;Dog&lt;/code&gt; or other classes.&lt;/p&gt;

&lt;h3 id=&#34;with-dependency-injection:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;With Dependency Injection&lt;/h3&gt;

&lt;p&gt;Now is the time to start taking advantage of dependency injection. Here we are going to introduce &lt;code&gt;AnimalType&lt;/code&gt; protocol to get rid of the dependency.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol AnimalType {
    var name: String { get }
    func sound() -&amp;gt; String
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Cat&lt;/code&gt; class is modified to conform the protocol,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Cat: AnimalType {
    let name: String

    init(name: String) {
        self.name = name
    }

    func sound() -&amp;gt; String {
        return &amp;quot;Meow!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and &lt;code&gt;PetOwner&lt;/code&gt; class is modified to get an &lt;code&gt;AnimalType&lt;/code&gt; injected through its initializer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class PetOwner {
    let pet: AnimalType

    init(pet: AnimalType) {
        self.pet = pet
    }

    func play() -&amp;gt; String {
        return &amp;quot;I&#39;m playing with \(pet.name). \(pet.sound())&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can inject the dependency to &lt;code&gt;AnimalType&lt;/code&gt; protocol when a &lt;code&gt;PetOwner&lt;/code&gt; instance is created.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let catOwner = PetOwner(pet: Cat(name: &amp;quot;Mimi&amp;quot;))
print(catOwner.play()) // prints &amp;quot;I&#39;m playing with Mimi. Meow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we have &lt;code&gt;Dog&lt;/code&gt; class,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Dog: AnimalType {
    let name: String

    init(name: String) {
        self.name = name
    }

    func sound() -&amp;gt; String {
        return &amp;quot;Bow wow!&amp;quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can play with a dog too.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let dogOwner = PetOwner(pet: Dog(name: &amp;quot;Hachi&amp;quot;))
print(dogOwner.play()) // prints &amp;quot;I&#39;m playing with Hachi. Bow wow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, we injected the dependency of &lt;code&gt;PetOwner&lt;/code&gt; by ourselves, but if we get more dependencies as the app evolved, it is harder to maintain dependency injection by hand. Let&amp;rsquo;s introduce Swinject to manage the dependencies here.&lt;/p&gt;

&lt;p&gt;To use Swinject, add the following line to a playground or source code.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Swinject
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then create an instance of &lt;code&gt;Container&lt;/code&gt; and register the dependency.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let container = Container()
container.register(AnimalType.self) { _ in Cat(name: &amp;quot;Mimi&amp;quot;) }
container.register(PetOwner.self) { r in
    PetOwner(pet: r.resolve(AnimalType.self)!)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code above, we told the &lt;code&gt;container&lt;/code&gt; to resolve &lt;code&gt;AnimalType&lt;/code&gt; to a &lt;code&gt;Cat&lt;/code&gt; instance named &amp;ldquo;Mimi&amp;rdquo;, and &lt;code&gt;PetOwner&lt;/code&gt; to an instance with an &lt;code&gt;AnimalType&lt;/code&gt; as a pet resolved by the &lt;code&gt;container&lt;/code&gt;. The &lt;code&gt;resolve&lt;/code&gt; method returns nil if the container cannot resolve an instance, but here we know &lt;code&gt;AnimalType&lt;/code&gt; is already registered and force-unwrap the optional parameter.&lt;/p&gt;

&lt;p&gt;We have got the configured container. Let&amp;rsquo;s get an instance of &lt;code&gt;PetOwner&lt;/code&gt; from the &lt;code&gt;container&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let petOwner = container.resolve(PetOwner.self)!
print(petOwner.play()) // prints &amp;quot;I&#39;m playing with Mimi. Meow!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is so simple to configure a &lt;code&gt;Container&lt;/code&gt; and to retrieve a resolved instance with its dependencies injected.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:144b804cfefadcc68c3843d860fdf9b1&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;The concept of dependency injection has been introduced with the scenario to write unit tests for the weather app, and its basic use case has been demonstrated. With Swinject, it is easy to configure the dependencies and to get instances with the dependencies resolved. &lt;a href=&#34;https://yoichitgy.github.io/post/dependency-injection-framework-for-swift-simple-weather-app-example-with-swinject-part-1/&#34;&gt;In the next blog post&lt;/a&gt;, we will see how to use Swinject with unit tests in the example weather app.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;The cities listed in the example app are the summer Olympic host cities since 1976.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;DI container is also called assembler, provider, builder, spring or injector.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;Specify version 0.1.0 if you use Xcode 6.4. Version 0.2 is required for Xcode 7 beta.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:3&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;Specify version 0.1 if you use Xcode 6.4. Version 0.2 is required for Xcode 7 beta.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:144b804cfefadcc68c3843d860fdf9b1:4&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>